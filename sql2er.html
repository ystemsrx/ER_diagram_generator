<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SQL/DBML2ER</title>
    <link rel="stylesheet" href="https://unpkg.com/antd@5.19.1/dist/reset.css" />
    <link rel="stylesheet" href="https://unpkg.com/antd@5.19.1/dist/antd.min.css" />
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/codemirror.min.css" />
    <style>
        :root {
            --primary: #0f172a;
            --primary-light: #334155;
            --secondary: #64748b;
            --accent: #0ea5e9;
            /* Sky 500 */
            --accent-hover: #0284c7;
            --accent-gradient: linear-gradient(135deg, #0ea5e9 0%, #2563eb 100%);
            --success: #10b981;
            --bg-page: #f8fafc;
            --bg-card: rgba(255, 255, 255, 0.7);
            --border: rgba(226, 232, 240, 0.8);
            --glass-border: 1px solid rgba(255, 255, 255, 0.6);
            --glass-shadow: 0 10px 40px -10px rgba(0, 0, 0, 0.05);
            --text-main: #1e293b;
            --text-sub: #64748b;
            --radius-lg: 24px;
            --radius-md: 16px;
            --radius-sm: 12px;
            --font-sans: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            --font-mono: 'JetBrains Mono', 'SF Mono', Consolas, monospace;
        }

        * {
            box-sizing: border-box;
            outline: none;
        }

        body {
            background-color: var(--bg-page);
            background-image:
                radial-gradient(circle at 0% 0%, rgba(14, 165, 233, 0.08) 0%, transparent 50%),
                radial-gradient(circle at 100% 100%, rgba(99, 102, 241, 0.08) 0%, transparent 50%);
            background-attachment: fixed;
            color: var(--text-main);
            font-family: var(--font-sans);
            min-height: 100vh;
            margin: 0;
            padding: 0;
            line-height: 1.6;
            -webkit-font-smoothing: antialiased;
        }

        .app-container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 40px 32px;
        }

        .header {
            text-align: center;
            margin-bottom: 32px;
            animation: fadeInDown 1s cubic-bezier(0.16, 1, 0.3, 1);
        }

        .header h1 {
            font-size: 3.5rem;
            font-weight: 800;
            background: linear-gradient(135deg, #0f172a 0%, #334155 100%);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            margin: 0 0 16px 0;
            letter-spacing: -0.03em;
            line-height: 1.1;
        }

        .header p {
            font-size: 1.25rem;
            color: var(--text-sub);
            margin: 0;
            font-weight: 400;
            opacity: 0.8;
        }

        .main-content {
            display: grid;
            grid-template-columns: 420px 1fr;
            gap: 32px;
            align-items: stretch;
            animation: fadeInUp 1s cubic-bezier(0.16, 1, 0.3, 1) 0.2s backwards;
        }

        .card {
            background: var(--bg-card);
            -webkit-backdrop-filter: blur(20px);
            backdrop-filter: blur(20px);
            border-radius: var(--radius-lg);
            box-shadow: var(--glass-shadow);
            border: var(--glass-border);
            overflow: hidden;
            display: flex;
            flex-direction: column;
            height: 100%;
        }

        .card-header {
            padding: 24px 32px;
            border-bottom: 1px solid rgba(226, 232, 240, 0.6);
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: rgba(255, 255, 255, 0.4);
        }

        .card-title {
            font-size: 1.2rem;
            font-weight: 700;
            color: var(--primary);
            margin: 0;
            display: flex;
            align-items: center;
            gap: 10px;
            letter-spacing: -0.01em;
        }

        .card-content {
            padding: 32px;
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 24px;
        }

        .input-textarea {
            width: 100%;
            min-height: 480px;
            border: 1px solid transparent;
            border-radius: var(--radius-md);
            padding: 20px;
            font-family: var(--font-mono);
            font-size: 14px;
            line-height: 1.6;
            background: #fff;
            color: var(--text-main);
            resize: none;
            transition: all 0.3s ease;
            flex: 1;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.02);
        }

        .input-textarea:focus {
            outline: none;
            background: #fff;
            box-shadow: 0 0 0 4px rgba(14, 165, 233, 0.1), inset 0 2px 4px rgba(0, 0, 0, 0.02);
        }

        .btn {
            height: 48px;
            border: none;
            border-radius: 9999px;
            font-size: 15px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.16, 1, 0.3, 1);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            width: 100%;
            letter-spacing: 0.01em;
        }

        .btn-primary {
            background: var(--accent-gradient);
            color: white;
            box-shadow: 0 4px 12px rgba(14, 165, 233, 0.3);
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(14, 165, 233, 0.4);
        }

        .btn-primary:active {
            transform: translateY(0);
        }

        .btn-primary:disabled {
            opacity: 0.7;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .btn-secondary {
            background: white;
            color: var(--text-main);
            border: 1px solid var(--border);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.02);
        }

        .btn-secondary:hover {
            background: #f8fafc;
            border-color: #cbd5e1;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
        }

        .btn-secondary:active {
            transform: translateY(0);
            background: #f1f5f9;
        }

        .btn-sm {
            height: 36px;
            padding: 0 20px;
            font-size: 13px;
            border-radius: 9999px;
            width: auto;
        }

        .btn-accent {
            background: rgba(14, 165, 233, 0.1);
            color: var(--accent);
            border: 1px solid rgba(14, 165, 233, 0.2);
        }

        .btn-accent:hover {
            background: rgba(14, 165, 233, 0.15);
            transform: translateY(-1px);
        }

        .btn-accent:active {
            transform: translateY(0);
            background: rgba(14, 165, 233, 0.2);
        }

        .diagram-container {
            width: 100%;
            flex: 1;
            min-height: 600px;
            background-color: #ffffff;
            background-image: radial-gradient(#cbd5e1 1.5px, transparent 1.5px);
            background-size: 24px 24px;
            border-radius: var(--radius-md);
            position: relative;
            overflow: hidden;
            border: 1px solid rgba(226, 232, 240, 0.6);
            box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.01);
            transition: background-image 0.3s ease;
        }

        .diagram-container.no-grid {
            background-image: none;
        }

        .background-toggle {
            position: absolute;
            top: 16px;
            left: 16px;
            width: 40px;
            height: 40px;
            background: rgba(255, 255, 255, 0.9);
            -webkit-backdrop-filter: blur(10px);
            backdrop-filter: blur(10px);
            border-radius: 50%;
            border: 1px solid rgba(226, 232, 240, 0.6);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            z-index: 100;
        }

        .background-toggle:hover {
            background: rgba(255, 255, 255, 1);
            transform: scale(1.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        .background-toggle i {
            font-size: 18px;
            color: var(--accent);
            transition: color 0.3s ease;
        }

        .background-toggle:hover i {
            color: var(--accent-hover);
        }

        .background-toggle:active {
            transform: scale(0.95);
        }

        .colorize-toggle {
            position: absolute;
            top: 66px;
            left: 16px;
            width: 40px;
            height: 40px;
            background: rgba(255, 255, 255, 0.9);
            -webkit-backdrop-filter: blur(10px);
            backdrop-filter: blur(10px);
            border-radius: 50%;
            border: 1px solid rgba(226, 232, 240, 0.6);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            z-index: 100;
        }

        .colorize-toggle:hover {
            background: rgba(255, 255, 255, 1);
            transform: scale(1.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        .colorize-toggle i {
            font-size: 18px;
            transition: color 0.3s ease;
        }

        .colorize-toggle.active {
            background: linear-gradient(135deg, #dbeafe 0%, #f3e8ff 50%, #ffe4e6 100%);
            border-color: rgba(14, 165, 233, 0.3);
        }

        .colorize-toggle.active:hover {
            background: linear-gradient(135deg, #bfdbfe 0%, #e9d5ff 50%, #fecdd3 100%);
        }

        .colorize-toggle.active i {
            color: var(--accent);
        }

        .colorize-toggle:not(.active) i {
            color: var(--secondary);
        }

        .colorize-toggle:hover i {
            color: var(--accent-hover);
        }

        .colorize-toggle:active {
            transform: scale(0.95);
        }

        .colorize-toggle.active:active {
            transform: scale(0.95);
        }

        .button-group {
            display: flex;
            gap: 16px;
            margin-top: auto;
        }

        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255, 255, 255, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10;
            -webkit-backdrop-filter: blur(4px);
            backdrop-filter: blur(4px);
            transition: all 0.3s ease;
        }

        .spinner {
            width: 48px;
            height: 48px;
            border: 4px solid rgba(14, 165, 233, 0.1);
            border-radius: 50%;
            border-top-color: var(--accent);
            animation: spin 1s cubic-bezier(0.5, 0, 0.5, 1) infinite;
        }

        .error-message {
            background: #fef2f2;
            color: #ef4444;
            padding: 16px 20px;
            border-radius: var(--radius-md);
            margin-bottom: 20px;
            border: 1px solid #fee2e2;
            font-size: 0.95rem;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 6px 12px;
            background: rgba(255, 255, 255, 0.5);
            border-radius: 20px;
            border: 1px solid rgba(0, 0, 0, 0.05);
            font-size: 0.85rem;
            color: var(--text-sub);
            transition: all 0.2s ease;
        }

        .legend-item:hover {
            background: #fff;
            transform: translateY(-1px);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.03);
        }

        @keyframes fadeInDown {
            from {
                opacity: 0;
                transform: translateY(-30px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        /* Tablet and below */
        @media (max-width: 1200px) {
            .main-content {
                grid-template-columns: 1fr;
            }

            .app-container {
                padding: 24px;
            }
        }

        /* Mobile and small tablets */
        @media (max-width: 768px) {
            /* ç¦ç”¨ç§»åŠ¨ç«¯çš„hoveræ•ˆæœ,é¿å…ç‚¹å‡»åçŠ¶æ€ä¿æŒ */
            .btn-primary:hover {
                transform: none;
                box-shadow: 0 4px 12px rgba(14, 165, 233, 0.3);
            }

            .btn-secondary:hover {
                transform: none;
                background: white;
                border-color: var(--border);
                box-shadow: 0 2px 4px rgba(0, 0, 0, 0.02);
            }

            .btn-accent:hover {
                transform: none;
                background: rgba(14, 165, 233, 0.1);
            }

            .background-toggle:hover {
                transform: none;
                background: rgba(255, 255, 255, 0.9);
                box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            }

            .background-toggle:hover i {
                color: var(--accent);
            }

            .colorize-toggle:hover {
                transform: none;
                background: rgba(255, 255, 255, 0.9);
                box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            }

            .colorize-toggle.active:hover {
                transform: none;
                background: linear-gradient(135deg, #dbeafe 0%, #f3e8ff 50%, #ffe4e6 100%);
            }

            .colorize-toggle:hover i {
                color: var(--secondary);
            }

            .colorize-toggle.active:hover i {
                color: var(--accent);
            }

            /* ç§»åŠ¨ç«¯activeçŠ¶æ€:ç‚¹å‡»æ—¶æ”¾å¤§æ•ˆæœ */
            .btn-primary:active {
                transform: scale(1.05);
            }

            .btn-secondary:active {
                transform: scale(1.05);
                background: #f1f5f9;
            }

            .btn-accent:active {
                transform: scale(1.05);
                background: rgba(14, 165, 233, 0.2);
            }

            .background-toggle:active {
                transform: scale(1.15);
            }

            .colorize-toggle:active,
            .colorize-toggle.active:active {
                transform: scale(1.15);
            }

            .app-container {
                padding: 16px;
            }

            .header {
                margin-bottom: 32px;
            }

            .header h1 {
                font-size: 2.5rem;
            }

            .header p {
                font-size: 1rem;
            }

            .main-content {
                gap: 20px;
            }

            .card-header {
                padding: 16px 20px;
            }

            .card-content {
                padding: 20px;
                gap: 16px;
            }

            .card-title {
                font-size: 1rem;
            }

            .input-textarea {
                min-height: 250px;
                padding: 16px;
                font-size: 13px;
            }

            .CodeMirror {
                height: 300px !important;
                font-size: 13px;
            }

            .button-group {
                gap: 10px;
            }

            .btn {
                height: 44px;
                font-size: 13px;
            }

            .btn-sm {
                height: 38px;
                font-size: 13px;
            }

            .diagram-container {
                min-height: 400px;
                border-radius: var(--radius-md);
            }
        }

        /* Small mobile phones */
        @media (max-width: 480px) {
            .app-container {
                padding: 12px;
            }

            .header {
                margin-bottom: 24px;
            }

            .header h1 {
                font-size: 1.75rem;
                letter-spacing: -0.02em;
            }

            .header p {
                font-size: 0.875rem;
            }

            .main-content {
                gap: 16px;
            }

            .card {
                border-radius: var(--radius-md);
            }

            .card-header {
                padding: 12px 16px;
            }

            .card-content {
                padding: 16px;
                gap: 12px;
            }

            /* éšè—ERé¢„è§ˆåŒºçš„æç¤ºæ–‡æœ¬å’Œåˆ†éš”ç¬¦ */
            .card-header>div:last-child>div:first-child {
                display: none !important;
            }

            .card-header>div:last-child .ant-switch {
                transform: scale(0.85);
            }

            /* æ‰‹æœºç‰ˆéšè—å›¾ä¾‹ */
            .output-section .card-header>div:first-child {
                display: none !important;
            }

            /* æ‰‹æœºç‰ˆæ§åˆ¶åŒºåŸŸå±…ä¸­ */
            .output-section .card-header {
                justify-content: center !important;
            }

            .output-section .card-header>div:last-child {
                margin: 0 !important;
                flex-wrap: wrap;
                gap: 8px !important;
                justify-content: center;
            }

            .card-title {
                font-size: 0.9rem;
            }

            .card-title span {
                font-size: 1.2rem !important;
            }

            .input-textarea {
                min-height: 200px;
                padding: 12px;
                font-size: 12px;
            }

            .CodeMirror {
                height: 250px !important;
                font-size: 12px;
            }

            .button-group {
                gap: 8px;
            }

            .btn {
                height: 40px;
                font-size: 12px;
                padding: 0 12px;
            }

            .btn-sm {
                height: 32px;
                font-size: 11px;
                padding: 0 10px;
                gap: 4px;
            }

            .diagram-container {
                min-height: 300px;
                border-radius: 12px;
                background-size: 16px 16px;
            }

            .legend-item {
                font-size: 0.75rem;
                padding: 4px 10px;
            }

            .error-message {
                padding: 12px 16px;
                font-size: 0.875rem;
            }

            /* éšè—ERé¢„è§ˆæ ‡å¤´ä¸­çš„æç¤ºæ–‡æœ¬å’Œåˆ†éš”ç¬¦ */
            .output-section .card-header>div:last-child>div:first-child,
            .output-section .card-header>div:last-child>div:nth-child(2) {
                display: none;
            }

            /* æ‰‹æœºç‰ˆéšè—å›¾ä¾‹ */
            .output-section .card-header>div:first-child {
                display: none !important;
            }

            /* æ‰‹æœºç‰ˆæ§åˆ¶åŒºåŸŸå±…ä¸­ */
            .output-section .card-header {
                justify-content: center !important;
            }

            .output-section .card-header>div:last-child {
                margin: 0 !important;
                flex-wrap: wrap;
                gap: 8px !important;
                justify-content: center;
            }
        }

        .CodeMirror {
            height: 480px !important;
            font-family: var(--font-mono) !important;
            font-size: 14px;
            line-height: 1.6;
            background: #fff;
        }

        .CodeMirror-gutters {
            background: #f8fafc;
            border-right: 1px solid #e2e8f0;
        }

        .CodeMirror-linenumber {
            color: #94a3b8;
        }

        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: transparent;
        }

        ::-webkit-scrollbar-thumb {
            background: #cbd5e1;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #94a3b8;
        }

        /* GitHub Corner - ç«‹ä½“çº¸å¼ æŠ˜å æ•ˆæœ */
        .github-corner {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 9999;
            border: 0;
            width: 80px;
            height: 80px;
            overflow: hidden;
        }

        .github-corner svg {
            fill: #0f172a;
            color: #fff;
            position: absolute;
            top: 0;
            border: 0;
            left: 0;
            transition: all 0.3s ease;
            filter: drop-shadow(2px 2px 4px rgba(0, 0, 0, 0.2));
            transform: scaleX(-1);
        }

        /* çº¸å¼ æŠ˜å æ•ˆæœ - ä¸Šå±‚é˜´å½± */
        .github-corner::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 0;
            height: 0;
            border-style: solid;
            border-width: 80px 80px 0 0;
            border-color: rgba(15, 23, 42, 0.05) transparent transparent transparent;
            pointer-events: none;
            transition: all 0.3s ease;
        }

        /* çº¸å¼ æŠ˜å æ•ˆæœ - ä¸‹å±‚é˜´å½± */
        .github-corner::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 0;
            height: 0;
            border-style: solid;
            border-width: 0 0 80px 80px;
            border-color: transparent transparent rgba(0, 0, 0, 0.03) transparent;
            pointer-events: none;
            transition: all 0.3s ease;
            transform-origin: top left;
        }

        .github-corner:hover::before {
            border-color: rgba(15, 23, 42, 0.1) transparent transparent transparent;
        }

        .github-corner:hover::after {
            border-color: transparent transparent rgba(0, 0, 0, 0.06) transparent;
        }

        .github-corner:hover svg {
            filter: drop-shadow(3px 3px 6px rgba(0, 0, 0, 0.3));
            transform: scaleX(-1.05) scaleY(1.05);
        }

        .github-corner .octo-arm {
            transform-origin: 130px 106px;
        }

        .github-corner:hover .octo-arm {
            animation: octocat-wave 560ms ease-in-out;
        }

        @keyframes octocat-wave {

            0%,
            100% {
                transform: rotate(0);
            }

            20%,
            60% {
                transform: rotate(-25deg);
            }

            40%,
            80% {
                transform: rotate(10deg);
            }
        }

        @media (max-width: 500px) {
            .github-corner:hover .octo-arm {
                animation: none;
            }

            .github-corner .octo-arm {
                animation: octocat-wave 560ms ease-in-out;
            }

            .github-corner {
                width: 60px;
                height: 60px;
            }

            .github-corner svg {
                width: 60px;
                height: 60px;
            }
        }
    </style>
</head>

<body>
    <a href="https://github.com/ystemsrx/ER_diagram_generator" class="github-corner" aria-label="View source on GitHub"
        target="_blank" rel="noopener noreferrer">
        <svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true">
            <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
            <path
                d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
                fill="currentColor" class="octo-arm"></path>
            <path
                d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
                fill="currentColor" class="octo-body"></path>
        </svg>
    </a>
    <div class="app-container">
        <div class="header">
            <h1>SQL/DBMLè½¬ERå›¾ç”Ÿæˆå™¨</h1>
            <p>åŸºäºChenæ¨¡å‹çš„æ•°æ®åº“è®¾è®¡å·¥å…·</p>
            <p style="font-size: 0.9rem; color: #94a3b8; margin-top: 8px;">ğŸ–±ï¸ åŒå‡»ç¼–è¾‘ â€¢ æ»šè½®ç¼©æ”¾</p>
        </div>

        <div id="root"></div>
    </div>

    <!-- Dependencies -->
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://unpkg.com/dayjs@1.11.10/dayjs.min.js"></script>
    <script src="https://unpkg.com/antd@5.19.1/dist/antd.min.js"></script>
    <script src="https://unpkg.com/@antv/g6@4.8.24/dist/g6.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/codemirror.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/sql/sql.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/javascript/javascript.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/addon/display/placeholder.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/addon/edit/matchbrackets.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/addon/edit/closebrackets.min.js"></script>

    <!-- Main Application Script -->
    <script type="text/babel">
        window.addEventListener('load', () => {
            const { useState, useEffect, useRef } = React;
            const { Switch } = window.antd;
            const G6 = window.G6;

            // Simple SQL Parser for CREATE TABLE statements
            const parseSQLTables = (sql) => {
                const tables = [];
                const relationships = [];

                // Remove comments and normalize whitespace
                const cleanSql = sql
                    .replace(/--.*$/gm, '')
                    .replace(/\/\*[\s\S]*?\*\//g, '')
                    .trim();

                // Split SQL into individual statements. This is more robust.
                const statements = cleanSql.split(';').filter(s => s.trim());

                statements.forEach(statement => {
                    // We only care about CREATE TABLE statements
                    const createTableMatch = statement.match(/^\s*CREATE\s+TABLE/i);
                    if (!createTableMatch) {
                        return;
                    }

                    // Extract table name
                    const tableNameMatch = statement.match(/CREATE\s+TABLE\s+(?:IF\s+NOT\s+EXISTS\s+)?\`?([\w\u4e00-\u9fa5]+)\`?/i);
                    if (!tableNameMatch) return;

                    const tableName = tableNameMatch[1];

                    // Manually find the content within the main parentheses to avoid complex regex
                    const openParenIndex = statement.indexOf('(');
                    if (openParenIndex === -1) return;

                    let closeParenIndex = -1;
                    let parenDepth = 0;
                    for (let i = openParenIndex + 1; i < statement.length; i++) {
                        const char = statement[i];
                        if (char === '(') {
                            parenDepth++;
                        } else if (char === ')') {
                            if (parenDepth === 0) {
                                closeParenIndex = i;
                                break;
                            }
                            parenDepth--;
                        }
                    }

                    if (closeParenIndex === -1) {
                        return; // Malformed CREATE TABLE statement
                    }

                    const tableBody = statement.substring(openParenIndex + 1, closeParenIndex);

                    const columns = [];
                    const primaryKeys = [];
                    const foreignKeys = [];

                    // Split by commas, but be careful with nested parentheses for types like DECIMAL(10, 2)
                    const parts = [];
                    let currentPart = '';
                    let depth = 0;

                    for (let i = 0; i < tableBody.length; i++) {
                        const char = tableBody[i];
                        if (char === '(') depth++;
                        else if (char === ')') depth--;
                        else if (char === ',' && depth === 0) {
                            parts.push(currentPart.trim());
                            currentPart = '';
                            continue;
                        }
                        currentPart += char;
                    }
                    if (currentPart.trim()) parts.push(currentPart.trim());

                    parts.forEach(part => {
                        const trimmedPart = part.trim().replace(/,\s*$/, ''); // Clean trailing commas
                        if (!trimmedPart) return;

                        // Check for PRIMARY KEY constraint at the table level
                        if (/^PRIMARY\s+KEY\s*\((.*)\)/i.test(trimmedPart)) {
                            const pkMatch = trimmedPart.match(/^PRIMARY\s+KEY\s*\((.*)\)/i);
                            if (pkMatch) {
                                const pkColumns = pkMatch[1].split(',').map(col => col.trim().replace(/[`"']/g, ''));
                                primaryKeys.push(...pkColumns);
                            }
                        }
                        // Check for FOREIGN KEY constraint
                        else if (/^(?:CONSTRAINT\s+\S+\s+)?FOREIGN\s+KEY/i.test(trimmedPart)) {
                            const fkMatch = trimmedPart.match(/^(?:CONSTRAINT\s+\S+\s+)?FOREIGN\s+KEY\s*\(\s*\`?([\w\u4e00-\u9fa5]+)\`?\s*\)\s+REFERENCES\s+\`?([\w\u4e00-\u9fa5]+)\`?\s*\(\s*\`?([\w\u4e00-\u9fa5]+)\`?\s*\)/i);
                            if (fkMatch) {
                                foreignKeys.push({
                                    column: fkMatch[1],
                                    referencedTable: fkMatch[2],
                                    referencedColumn: fkMatch[3]
                                });
                            }
                        }
                        // Regular column definition
                        else if (/^(\`?[\w\u4e00-\u9fa5]+\`?)\s+/.test(trimmedPart)) {
                            const columnMatch = trimmedPart.match(/^(\`?[\w\u4e00-\u9fa5]+\`?)\s+(\w+(?:\(\d+(?:,\s*\d+)?\))?)(.*)/i);
                            if (columnMatch) {
                                const columnName = columnMatch[1].replace(/`/g, '');
                                const dataType = columnMatch[2];
                                const constraints = columnMatch[3] || '';

                                const isPrimaryKey = /PRIMARY\s+KEY/i.test(constraints);
                                if (isPrimaryKey) {
                                    primaryKeys.push(columnName);
                                }

                                columns.push({
                                    name: columnName,
                                    type: dataType,
                                    isPrimaryKey
                                });
                            }
                        }
                    });

                    tables.push({
                        name: tableName,
                        columns,
                        primaryKeys,
                        foreignKeys
                    });

                    // Add relationships
                    foreignKeys.forEach(fk => {
                        relationships.push({
                            from: tableName,
                            to: fk.referencedTable,
                            label: fk.column
                        });
                    });
                });

                return { tables, relationships };
            };

            // DBML Parser
            const parseDBML = (dbml) => {
                const tables = [];
                const relationships = [];

                // Remove comments and normalize whitespace
                const cleanDbml = dbml
                    .replace(/\/\/.*$/gm, '')
                    .replace(/\/\*[\s\S]*?\*\//g, '')
                    .trim();

                const tableRegex = /Table\s+`?([\w\u4e00-\u9fa5]+)`?(?:\s+as\s+`?([\w\u4e00-\u9fa5]+)`?)?\s*\{([\s\S]*?)\}/g;
                let tableMatch;

                while ((tableMatch = tableRegex.exec(cleanDbml)) !== null) {
                    const tableName = tableMatch[1];
                    const tableAlias = tableMatch[2];
                    const tableBody = tableMatch[3].trim();
                    const columns = [];
                    const primaryKeys = [];
                    const foreignKeys = [];

                    tableBody.split('\n').forEach(line => {
                        if (!line.trim()) return;

                        // Match `column_name` type [attributes]
                        const columnMatch = line.trim().match(/^`?([\w\u4e00-\u9fa5]+)`?\s+([\w\d\(\)\s,]+)(?:\s*\[([^\]]*)\])?/);

                        if (columnMatch) {
                            const columnName = columnMatch[1];
                            const columnType = columnMatch[2].trim();
                            const attributesStr = columnMatch[3] || '';

                            const isPrimaryKey = attributesStr.includes('pk') || attributesStr.includes('primary key');

                            if (isPrimaryKey) {
                                primaryKeys.push(columnName);
                            }

                            // Handle inline references
                            const refMatch = attributesStr.match(/ref:\s*(?:[-><])\s*`?([\w\u4e00-\u9fa5]+)`?\.`?([\w\u4e00-\u9fa5]+)`?/);
                            if (refMatch) {
                                const toTable = refMatch[1];
                                const toColumn = refMatch[2];

                                relationships.push({
                                    from: tableName,
                                    to: toTable,
                                    label: columnName
                                });

                                foreignKeys.push({
                                    column: columnName,
                                    referencedTable: toTable,
                                    referencedColumn: toColumn
                                });
                            }

                            columns.push({
                                name: columnName,
                                type: columnType,
                                isPrimaryKey: isPrimaryKey
                            });
                        }
                    });

                    tables.push({
                        name: tableName,
                        alias: tableAlias,
                        columns,
                        primaryKeys,
                        foreignKeys: foreignKeys
                    });
                }

                // æ”¯æŒä¸­æ–‡è¡¨åå’Œåˆ—åçš„ Ref è¯­å¥
                const refRegex = /Ref\s*:\s*`?([\w\u4e00-\u9fa5]+)`?\.`?([\w\u4e00-\u9fa5]+)`?\s*[-><]\s*`?([\w\u4e00-\u9fa5]+)`?\.`?([\w\u4e00-\u9fa5]+)`?/g;
                let refMatch;

                while ((refMatch = refRegex.exec(cleanDbml)) !== null) {
                    const fromTable = refMatch[1];
                    const fromColumn = refMatch[2];
                    const toTable = refMatch[3];
                    const toColumn = refMatch[4];

                    relationships.push({
                        from: fromTable,
                        to: toTable,
                        label: fromColumn
                    });

                    const table = tables.find(t => t.name === fromTable);
                    if (table) {
                        if (!table.foreignKeys) {
                            table.foreignKeys = [];
                        }
                        table.foreignKeys.push({
                            column: fromColumn,
                            referencedTable: toTable,
                            referencedColumn: toColumn
                        });
                    }
                }

                return { tables, relationships };
            };

            // Generate Chen Model ER diagram data
            const generateChenModelData = (tables, relationships, isColored = true) => {
                const nodes = [];
                const edges = [];
                const entityMap = new Map(); // ç”¨äºå­˜å‚¨è¡¨ååˆ°å®ä½“IDçš„æ˜ å°„

                // Create entity nodes (rectangles) - ä¸è®¾ç½®å›ºå®šä½ç½®ï¼Œè®©å¸ƒå±€ç®—æ³•å¤„ç†
                tables.forEach((table, tableIndex) => {
                    const entityId = `entity-${table.name}-${tableIndex}`;
                    entityMap.set(table.name, entityId); // è®°å½•æ˜ å°„å…³ç³»
                    if (table.alias) {
                        entityMap.set(table.alias, entityId);
                    }

                    nodes.push({
                        id: entityId,
                        type: 'entity',
                        label: table.name,
                        // ç§»é™¤å›ºå®šçš„x,yåæ ‡ï¼Œè®©å¸ƒå±€ç®—æ³•è‡ªåŠ¨å¤„ç†
                        style: {
                            fill: '#ffffff',
                            stroke: isColored ? '#595959' : '#000000',
                            lineWidth: 2
                        },
                        labelCfg: {
                            style: {
                                fill: '#000000',
                                fontWeight: 'bold'
                            }
                        },
                        // æ·»åŠ èŠ‚ç‚¹åˆ†ç±»ä¿¡æ¯ï¼Œç”¨äºå¸ƒå±€ç®—æ³•
                        nodeType: 'entity'
                    });

                    // Create attribute nodes (ellipses) for each column
                    table.columns.forEach((column, colIndex) => {
                        const attributeId = `attr-${table.name}-${column.name}-${tableIndex}-${colIndex}`;
                        const isPrimaryKey = table.primaryKeys.includes(column.name) || column.isPrimaryKey;

                        nodes.push({
                            id: attributeId,
                            type: 'attribute',
                            label: column.name,
                            // ç§»é™¤å›ºå®šä½ç½®
                            keyType: isPrimaryKey ? 'pk' : 'normal',
                            style: {
                                fill: isColored ? (isPrimaryKey ? '#f6ffed' : '#fffbe6') : '#ffffff',
                                stroke: isColored ? (isPrimaryKey ? '#52c41a' : '#faad14') : '#000000',
                                lineWidth: isPrimaryKey ? 2 : 1
                            },
                            labelCfg: {
                                style: {
                                    fill: '#000000',
                                    fontWeight: isPrimaryKey ? 'bold' : 'normal'
                                }
                            },
                            nodeType: 'attribute',
                            parentEntity: entityId // æ ‡è®°çˆ¶å®ä½“
                        });

                        // Connect attribute to entity
                        edges.push({
                            id: `edge-${entityId}-${attributeId}-${tableIndex}-${colIndex}`,
                            source: entityId,
                            target: attributeId,
                            style: {
                                stroke: '#000000'
                            },
                            edgeType: 'entity-attribute'
                        });
                    });
                });

                // Create relationship nodes (diamonds) and connections
                relationships.forEach((rel, relIndex) => {
                    const relationshipId = `rel-${rel.from}-${rel.to}-${rel.label}-${relIndex}`;

                    nodes.push({
                        id: relationshipId,
                        type: 'relationship',
                        label: rel.label,
                        style: {
                            fill: isColored ? '#f9f0ff' : '#ffffff',
                            stroke: isColored ? '#722ed1' : '#000000',
                            lineWidth: 2
                        },
                        labelCfg: {
                            style: {
                                fill: '#000000'
                            }
                        },
                        nodeType: 'relationship'
                    });

                    // Connect source entity (the one with the FK, 'many' side) to relationship
                    edges.push({
                        id: `edge-entity-${rel.from}-${relationshipId}-${relIndex}-1`,
                        source: entityMap.get(rel.from),
                        target: relationshipId,
                        label: 'N',
                        style: {
                            stroke: '#000000',
                            lineWidth: 2
                        },
                        labelCfg: {
                            style: {
                                fill: '#000000',
                                background: {
                                    fill: '#ffffff',
                                    padding: [2, 4, 2, 4]
                                }
                            }
                        },
                        edgeType: 'entity-relationship'
                    });

                    // Connect relationship to target entity (the one being referenced, 'one' side)
                    edges.push({
                        id: `edge-${relationshipId}-entity-${rel.to}-${relIndex}-2`,
                        source: relationshipId,
                        target: entityMap.get(rel.to),
                        label: '1',
                        style: {
                            stroke: '#000000',
                            lineWidth: 2
                        },
                        labelCfg: {
                            style: {
                                fill: '#000000',
                                background: {
                                    fill: '#ffffff',
                                    padding: [2, 4, 2, 4]
                                }
                            }
                        },
                        edgeType: 'relationship-entity'
                    });
                });

                return { nodes, edges };
            };

            // Register custom node types for Chen model
            G6.registerNode('entity', {
                draw(cfg, group) {
                    const fontSize = 18;
                    const text = cfg.label || '';

                    // è®¡ç®—æ–‡å­—å°ºå¯¸ï¼Œè€ƒè™‘ä¸­æ–‡å­—ç¬¦
                    const getTextWidth = (text, fontSize) => {
                        let width = 0;
                        for (let char of text) {
                            // ä¸­æ–‡å­—ç¬¦å®½åº¦çº¦ç­‰äºå­—ä½“å¤§å°ï¼Œè‹±æ–‡å­—ç¬¦çº¦ä¸ºå­—ä½“å¤§å°çš„0.6å€
                            if (/[\u4e00-\u9fa5]/.test(char)) {
                                width += fontSize;
                            } else {
                                width += fontSize * 0.6;
                            }
                        }
                        return width;
                    };

                    const textWidth = getTextWidth(text, fontSize);
                    const padding = 10; // æ°´å¹³å†…è¾¹è·ï¼Œä»20å‡å°åˆ°10
                    const minWidth = 80; // æœ€å°å®½åº¦
                    const minHeight = 50; // æœ€å°é«˜åº¦

                    const width = Math.max(minWidth, textWidth + padding * 2);
                    const height = Math.max(minHeight, fontSize + 20); // å‚ç›´å†…è¾¹è·

                    const shape = group.addShape('rect', {
                        attrs: {
                            x: -width / 2,
                            y: -height / 2,
                            width: width,
                            height: height,
                            fill: cfg.style?.fill || '#fff',
                            stroke: cfg.style?.stroke || '#000',
                            lineWidth: cfg.style?.lineWidth || 2
                        },
                        name: 'entity-shape'
                    });

                    if (cfg.label) {
                        group.addShape('text', {
                            attrs: {
                                x: 0,
                                y: 0,
                                text: cfg.label,
                                fontSize: fontSize,
                                textAlign: 'center',
                                textBaseline: 'middle',
                                fill: '#000',
                                fontWeight: 'bold'
                            },
                            name: 'entity-text',
                            capture: false
                        });
                    }

                    return shape;
                }
            });

            G6.registerNode('attribute', {
                draw(cfg, group) {
                    const fontSize = 15;
                    const text = cfg.label || '';

                    // è®¡ç®—æ–‡å­—å°ºå¯¸ï¼Œè€ƒè™‘ä¸­æ–‡å­—ç¬¦
                    const getTextWidth = (text, fontSize) => {
                        let width = 0;
                        for (let char of text) {
                            // ä¸­æ–‡å­—ç¬¦å®½åº¦çº¦ç­‰äºå­—ä½“å¤§å°ï¼Œè‹±æ–‡å­—ç¬¦çº¦ä¸ºå­—ä½“å¤§å°çš„0.6å€
                            if (/[\u4e00-\u9fa5]/.test(char)) {
                                width += fontSize;
                            } else {
                                width += fontSize * 0.6;
                            }
                        }
                        return width;
                    };

                    const textWidth = getTextWidth(text, fontSize);
                    const padding = 16; // æ°´å¹³å†…è¾¹è·
                    const minWidth = 60; // æœ€å°å®½åº¦
                    const minHeight = 40; // æœ€å°é«˜åº¦

                    const width = Math.max(minWidth, textWidth + padding * 2);
                    const height = Math.max(minHeight, fontSize + 16); // å‚ç›´å†…è¾¹è·

                    const shape = group.addShape('ellipse', {
                        attrs: {
                            x: 0,
                            y: 0,
                            rx: width / 2,
                            ry: height / 2,
                            fill: cfg.style?.fill || '#fff',
                            stroke: cfg.style?.stroke || '#000',
                            lineWidth: cfg.style?.lineWidth || 1
                        },
                        name: 'attribute-shape'
                    });

                    if (cfg.label) {
                        const isPrimaryKey = cfg.keyType === 'pk';
                        group.addShape('text', {
                            attrs: {
                                x: 0,
                                y: 0,
                                text: cfg.label,
                                fontSize: fontSize,
                                textAlign: 'center',
                                textBaseline: 'middle',
                                fill: '#000',
                                fontWeight: isPrimaryKey ? 'bold' : 'normal'
                            },
                            name: 'attribute-text',
                            capture: false
                        });

                        // Add underline for primary keys
                        if (isPrimaryKey) {
                            const textWidth = getTextWidth(text, fontSize); // ä½¿ç”¨ç²¾ç¡®çš„æ–‡å­—å®½åº¦è®¡ç®—
                            group.addShape('line', {
                                attrs: {
                                    x1: -textWidth / 2,
                                    y1: 12, // ä¸‹åˆ’çº¿ä½ç½®
                                    x2: textWidth / 2,
                                    y2: 12,
                                    stroke: '#000',
                                    lineWidth: 1
                                },
                                name: 'attribute-underline'
                            });
                        }
                    }

                    return shape;
                }
            });

            G6.registerNode('relationship', {
                draw(cfg, group) {
                    const fontSize = 16;
                    const text = cfg.label || '';

                    // è®¡ç®—æ–‡å­—å°ºå¯¸ï¼Œè€ƒè™‘ä¸­æ–‡å­—ç¬¦
                    const getTextWidth = (text, fontSize) => {
                        let width = 0;
                        for (let char of text) {
                            // ä¸­æ–‡å­—ç¬¦å®½åº¦çº¦ç­‰äºå­—ä½“å¤§å°ï¼Œè‹±æ–‡å­—ç¬¦çº¦ä¸ºå­—ä½“å¤§å°çš„0.6å€
                            if (/[\u4e00-\u9fa5]/.test(char)) {
                                width += fontSize;
                            } else {
                                width += fontSize * 0.6;
                            }
                        }
                        return width;
                    };

                    const textWidth = getTextWidth(text, fontSize);
                    const horizontalPadding = 24; // æ°´å¹³å†…è¾¹è·
                    const verticalPadding = 16; // å‚ç›´å†…è¾¹è·
                    const minWidth = 80; // æœ€å°å®½åº¦
                    const minHeight = 40; // æœ€å°é«˜åº¦

                    // è®¡ç®—è±å½¢çš„å®é™…å®½åº¦å’Œé«˜åº¦
                    // è±å½¢æ˜¯æ‰çš„ï¼Œå®½åº¦è¦æ¯”é«˜åº¦å¤§
                    const requiredWidth = textWidth + horizontalPadding * 2;
                    const requiredHeight = fontSize + verticalPadding * 2;

                    // è±å½¢çš„æ°´å¹³åŠå¾„ï¼ˆå®½åº¦çš„ä¸€åŠï¼‰
                    const halfWidth = Math.max(minWidth / 2, requiredWidth / 2);
                    // è±å½¢çš„å‚ç›´åŠå¾„ï¼ˆé«˜åº¦çš„ä¸€åŠï¼‰ï¼Œè®¾ç½®ä¸ºå®½åº¦çš„0.6å€ï¼Œè®©è±å½¢å˜æ‰
                    const halfHeight = Math.max(minHeight / 2, Math.min(halfWidth * 0.6, requiredHeight / 2));

                    const shape = group.addShape('polygon', {
                        attrs: {
                            points: [
                                [0, -halfHeight],        // ä¸Šé¡¶ç‚¹
                                [halfWidth, 0],          // å³é¡¶ç‚¹  
                                [0, halfHeight],         // ä¸‹é¡¶ç‚¹
                                [-halfWidth, 0]          // å·¦é¡¶ç‚¹
                            ],
                            fill: cfg.style?.fill || '#fff',
                            stroke: cfg.style?.stroke || '#000',
                            lineWidth: cfg.style?.lineWidth || 2
                        },
                        name: 'relationship-shape'
                    });

                    if (cfg.label) {
                        group.addShape('text', {
                            attrs: {
                                x: 0,
                                y: 0,
                                text: cfg.label,
                                fontSize: fontSize,
                                textAlign: 'center',
                                textBaseline: 'middle',
                                fill: '#000'
                            },
                            name: 'relationship-text',
                            capture: false
                        });
                    }

                    return shape;
                }
            });

            const CodeEditor = ({ value, onChange, placeholder }) => {
                const editorRef = useRef(null);
                const cmInstance = useRef(null);

                useEffect(() => {
                    if (!editorRef.current) return;

                    cmInstance.current = CodeMirror.fromTextArea(editorRef.current, {
                        mode: "text/x-sql",
                        lineNumbers: true,
                        theme: "default",
                        lineWrapping: true,
                        height: "480px",
                        placeholder: placeholder,
                        matchBrackets: true,
                        autoCloseBrackets: true
                    });

                    cmInstance.current.on('change', (cm) => {
                        const newValue = cm.getValue();
                        onChange(newValue);
                    });

                    cmInstance.current.setValue(value);

                    return () => {
                        if (cmInstance.current) {
                            cmInstance.current.toTextArea();
                        }
                    };
                }, []);

                useEffect(() => {
                    if (cmInstance.current && cmInstance.current.getValue() !== value) {
                        const cursor = cmInstance.current.getCursor();
                        cmInstance.current.setValue(value);
                        cmInstance.current.setCursor(cursor);
                    }
                }, [value]);

                return (
                    <div style={{ height: '480px', display: 'flex', flexDirection: 'column', border: '1px solid #e2e8f0', borderRadius: '16px', overflow: 'hidden' }}>
                        <textarea ref={editorRef} style={{ display: 'none' }} />
                    </div>
                );
            };

            const App = () => {
                const [showBackground, setShowBackground] = useState(true);
                const [inputText, setInputText] = useState(`// ç¤ºä¾‹DBMLï¼Œè¯·åœ¨æ­¤å¤„ç²˜è´´æ‚¨çš„ DBML æˆ– SQL è¯­å¥
Table ç”¨æˆ· {
  ç¼–å· INT [pk, increment]
  ç”¨æˆ·å VARCHAR(255) [not null]
  é‚®ç®± VARCHAR(255) [unique]
  åˆ›å»ºæ—¶é—´ TIMESTAMP
}

Table å›½å®¶ {
  ç¼–å· INT [pk]
  åç§° VARCHAR(255) [not null]
}

Table æ–‡ç«  {
  æ–‡ç« ç¼–å· INT [pk]
  å†…å®¹ TEXT
}

Ref: ç”¨æˆ·.å±äº > å›½å®¶.ç¼–å·
Ref: æ–‡ç« .ä½œè€… > ç”¨æˆ·.ç¼–å·
`);
                const [isColored, setIsColored] = useState(true);
                const [error, setError] = useState(null);
                const [loading, setLoading] = useState(false);
                const [hasGraph, setHasGraph] = useState(false);
                const lastInputRef = useRef(''); // è®°å½•ä¸Šæ¬¡ç”Ÿæˆæ—¶çš„è¾“å…¥
                const containerRef = useRef(null);
                const graphRef = useRef(null);

                // æ›´æ–°å›¾è¡¨æ ·å¼
                const updateGraphStyles = (graphInstance, colored) => {
                    if (!graphInstance || graphInstance.destroyed) return;

                    graphInstance.setAutoPaint(false);

                    const nodes = graphInstance.getNodes();
                    nodes.forEach(node => {
                        const model = node.getModel();
                        const styles = {};

                        if (colored) {
                            if (model.nodeType === 'entity') {
                                // Sky Blue theme
                                styles.style = {
                                    fill: '#e0f2fe',
                                    stroke: '#0ea5e9',
                                    lineWidth: 2,
                                    radius: 8,
                                    shadowColor: 'rgba(14, 165, 233, 0.2)',
                                    shadowBlur: 10
                                };
                                styles.labelCfg = { style: { fill: '#0f172a', fontWeight: '700', fontFamily: 'Inter' } };
                            } else if (model.nodeType === 'relationship') {
                                // Violet theme
                                styles.style = {
                                    fill: '#f5f3ff',
                                    stroke: '#8b5cf6',
                                    lineWidth: 2,
                                    shadowColor: 'rgba(139, 92, 246, 0.2)',
                                    shadowBlur: 10
                                };
                                styles.labelCfg = { style: { fill: '#0f172a', fontFamily: 'Inter' } };
                            } else if (model.nodeType === 'attribute') {
                                if (model.keyType === 'pk') {
                                    // Emerald theme
                                    styles.style = {
                                        fill: '#ecfdf5',
                                        stroke: '#10b981',
                                        lineWidth: 2,
                                        shadowColor: 'rgba(16, 185, 129, 0.2)',
                                        shadowBlur: 5
                                    };
                                    styles.labelCfg = { style: { fill: '#0f172a', fontWeight: '700', fontFamily: 'Inter' } };
                                } else {
                                    // Slate theme
                                    styles.style = {
                                        fill: '#ffffff',
                                        stroke: '#94a3b8', // Slate 400
                                        lineWidth: 2
                                    };
                                    styles.labelCfg = { style: { fill: '#475569', fontWeight: 'normal', fontFamily: 'Inter' } };
                                }
                            }
                        } else {
                            // é»‘ç™½æ¨¡å¼ (æ— å¡«å…… = ç™½è‰²èƒŒæ™¯)
                            styles.style = {
                                fill: '#ffffff',
                                stroke: '#1e293b',
                                lineWidth: model.keyType === 'pk' || model.nodeType === 'entity' || model.nodeType === 'relationship' ? 2 : 1,
                                shadowBlur: 0
                            };
                            styles.labelCfg = { style: { fill: '#1e293b', fontWeight: (model.nodeType === 'entity' || model.keyType === 'pk') ? 'bold' : 'normal', fontFamily: 'Inter' } };
                        }

                        graphInstance.updateItem(node, styles);
                    });

                    // åˆ·æ–°è¾¹
                    const edges = graphInstance.getEdges();
                    edges.forEach(edge => {
                        graphInstance.updateItem(edge, {
                            style: {
                                stroke: '#000000',
                                lineWidth: 1.5,
                                endArrow: false
                            },
                            labelCfg: {
                                style: {
                                    fill: '#000000',
                                    fontSize: 12,
                                    background: {
                                        fill: '#ffffff',
                                        padding: [2, 4, 2, 4],
                                        radius: 2
                                    }
                                }
                            }
                        });
                    });

                    graphInstance.paint();
                    graphInstance.setAutoPaint(true);
                };

                // ç›‘å¬ç€è‰²çŠ¶æ€å˜åŒ–
                useEffect(() => {
                    if (hasGraph && graphRef.current) {
                        updateGraphStyles(graphRef.current, isColored);
                    }
                }, [isColored, hasGraph]);

                // çœŸæ­£æœ‰æ•ˆçš„å¹³æ»‘ç¼©æ”¾å‡½æ•°
                const smoothFitView = (graph, duration = 800, easing = 'easeOutCubic') => {
                    if (!graph || graph.destroyed) return;

                    try {
                        // è·å–æ‰€æœ‰èŠ‚ç‚¹çš„è¾¹ç•Œæ¡†
                        const nodes = graph.getNodes();
                        if (!nodes || nodes.length === 0) {
                            graph.fitView(20);
                            return;
                        }

                        // è®¡ç®—æ‰€æœ‰èŠ‚ç‚¹çš„æ€»ä½“è¾¹ç•Œæ¡†
                        let minX = Infinity, maxX = -Infinity;
                        let minY = Infinity, maxY = -Infinity;

                        nodes.forEach(node => {
                            const bbox = node.getBBox();
                            minX = Math.min(minX, bbox.minX);
                            maxX = Math.max(maxX, bbox.maxX);
                            minY = Math.min(minY, bbox.minY);
                            maxY = Math.max(maxY, bbox.maxY);
                        });

                        // è¾¹ç•Œæ¡†çš„å®½åº¦å’Œé«˜åº¦
                        const contentWidth = maxX - minX;
                        const contentHeight = maxY - minY;
                        const contentCenterX = (minX + maxX) / 2;
                        const contentCenterY = (minY + maxY) / 2;

                        if (contentWidth === 0 || contentHeight === 0) {
                            graph.fitView(20);
                            return;
                        }

                        // ç”»å¸ƒå°ºå¯¸
                        const graphWidth = graph.get('width');
                        const graphHeight = graph.get('height');
                        const padding = 40; // è¾¹è·

                        // è®¡ç®—åˆé€‚çš„ç¼©æ”¾æ¯”ä¾‹ï¼Œè®©å†…å®¹å®Œå…¨æ˜¾ç¤ºåœ¨ç”»å¸ƒå†…ï¼Œä¸”å°½å¯èƒ½å¤§
                        const scaleX = (graphWidth - padding * 2) / contentWidth;
                        const scaleY = (graphHeight - padding * 2) / contentHeight;
                        const targetZoom = Math.min(scaleX, scaleY);

                        // è®¡ç®—ç›®æ ‡å¹³ç§»ï¼Œè®©å†…å®¹å±…ä¸­æ˜¾ç¤º
                        // åœ¨æ–°çš„ç¼©æ”¾æ¯”ä¾‹ä¸‹ï¼Œå†…å®¹ä¸­å¿ƒåº”è¯¥å¯¹åº”åˆ°ç”»å¸ƒä¸­å¿ƒ
                        const targetCenterX = graphWidth / 2 - contentCenterX * targetZoom;
                        const targetCenterY = graphHeight / 2 - contentCenterY * targetZoom;

                        // è·å–å½“å‰çŠ¶æ€
                        const currentZoom = graph.getZoom();
                        const currentMatrix = graph.get('group').getMatrix();
                        const currentCenterX = currentMatrix ? currentMatrix[6] : 0;
                        const currentCenterY = currentMatrix ? currentMatrix[7] : 0;

                        // æ‰§è¡Œå¹³æ»‘åŠ¨ç”»
                        const startTime = performance.now();

                        const animate = (currentTime) => {
                            if (!graph || graph.destroyed) return;

                            const elapsed = currentTime - startTime;
                            let progress = Math.min(elapsed / duration, 1);

                            // ç¼“åŠ¨å‡½æ•°
                            if (easing === 'easeOutQuart') {
                                progress = 1 - Math.pow(1 - progress, 4);
                            } else { // easeOutCubic
                                progress = 1 - Math.pow(1 - progress, 3);
                            }

                            // è®¡ç®—å½“å‰å¸§çš„å€¼
                            const frameZoom = currentZoom + (targetZoom - currentZoom) * progress;
                            const frameCenterX = currentCenterX + (targetCenterX - currentCenterX) * progress;
                            const frameCenterY = currentCenterY + (targetCenterY - currentCenterY) * progress;

                            // åº”ç”¨å˜æ¢
                            const groupMatrix = [frameZoom, 0, 0, 0, frameZoom, 0, frameCenterX, frameCenterY, 1];
                            graph.get('group').setMatrix(groupMatrix);
                            graph.paint();

                            // ç»§ç»­åŠ¨ç”»
                            if (progress < 1) {
                                requestAnimationFrame(animate);
                            }
                        };

                        requestAnimationFrame(animate);

                    } catch (error) {
                        console.warn('Smooth fit view failed, falling back to instant fit:', error);
                        graph.fitView(20);
                    }
                };

                // åŸºäºç›®æ ‡åæ ‡çš„èŠ‚ç‚¹å¹³æ»‘ç§»åŠ¨
                const animateNodesToTargets = (graph, targets, duration = 800, onFinish) => {
                    if (!graph || graph.destroyed || !targets?.size) {
                        if (onFinish) onFinish();
                        return;
                    }

                    const startPositions = new Map();
                    graph.getNodes().forEach(node => {
                        const model = node.getModel();
                        startPositions.set(model.id, { x: model.x, y: model.y });
                    });

                    const startTime = performance.now();
                    graph.setAutoPaint(false);

                    const step = (currentTime) => {
                        if (!graph || graph.destroyed) return;
                        const elapsed = currentTime - startTime;
                        const rawProgress = Math.min(elapsed / duration, 1);
                        const progress = 1 - Math.pow(1 - rawProgress, 3); // easeOutCubic

                        targets.forEach((target, id) => {
                            const node = graph.findById(id);
                            if (!node) return;
                            const start = startPositions.get(id) || target;
                            const x = start.x + (target.x - start.x) * progress;
                            const y = start.y + (target.y - start.y) * progress;
                            graph.updateItem(node, { x, y });
                        });

                        graph.paint();

                        if (rawProgress < 1) {
                            requestAnimationFrame(step);
                        } else {
                            graph.setAutoPaint(true);
                            if (onFinish) onFinish();
                        }
                    };

                    requestAnimationFrame(step);
                };

                // åŸºäºå­—ç¬¦ä¸²ç”Ÿæˆç¡®å®šæ€§å“ˆå¸Œå€¼ï¼ˆç”¨äºæ›¿ä»£Math.randomï¼‰
                const deterministicHash = (str, extraSeed = 0) => {
                    let hash = extraSeed; // åŠ å…¥é¢å¤–çš„ç§å­
                    for (let i = 0; i < str.length; i++) {
                        const char = str.charCodeAt(i);
                        hash = ((hash << 5) - hash) + char;
                        hash = hash & hash; // è½¬æ¢ä¸º32ä½æ•´æ•°
                    }
                    return Math.abs(hash);
                };

                // ç”Ÿæˆç¡®å®šæ€§çš„[-0.5, 0.5)èŒƒå›´å†…çš„æ•°å€¼
                const deterministicRandom = (seed, extraSeed = 0) => {
                    const x = Math.sin(seed + extraSeed * 1000) * 10000;
                    return (x - Math.floor(x)) - 0.5;
                };

                // åˆå§‹å®šä½ï¼šè®©äº’ä¸ç›¸è¿çš„ç»„ä»¶ä¸€å¼€å§‹å°±å›´ç»•ä¸­å¿ƒåˆ†å¸ƒï¼Œé¿å…å…ˆäº¤å‰å†åˆ†æ•£
                const applyInitialComponentPositions = (nodes, edges, containerEl, seed = 0) => {
                    if (!containerEl || !nodes.length) return;
                    if (nodes.length < 2) return;

                    const width = containerEl.offsetWidth || 1200;
                    const height = containerEl.offsetHeight || 800;
                    const center = { x: width / 2, y: height / 2 };

                    const sizeMap = {
                        entity: 140,
                        relationship: 90,
                        attribute: 90
                    };

                    const approxRadius = (node) => {
                        const size = sizeMap[node.nodeType] || 90;
                        return Math.sqrt(size * size * 2) / 2 + 20;
                    };

                    // æ„å»ºæ— å‘é‚»æ¥è¡¨
                    const adj = new Map();
                    edges.forEach(e => {
                        const { source, target } = e;
                        if (!adj.has(source)) adj.set(source, new Set());
                        if (!adj.has(target)) adj.set(target, new Set());
                        adj.get(source).add(target);
                        adj.get(target).add(source);
                    });

                    // åˆ’åˆ†ç»„ä»¶ï¼ˆæŒ‰IDæ’åºä»¥ç¡®ä¿ç¨³å®šæ€§ï¼‰
                    const visited = new Set();
                    const components = [];
                    const sortedNodes = [...nodes].sort((a, b) => a.id.localeCompare(b.id));
                    sortedNodes.forEach(n => {
                        if (visited.has(n.id)) return;
                        const stack = [n.id];
                        const comp = [];
                        visited.add(n.id);
                        while (stack.length) {
                            const cur = stack.pop();
                            const found = nodes.find(nn => nn.id === cur);
                            if (found) comp.push(found);
                            const neighbors = adj.get(cur);
                            if (!neighbors) continue;
                            // å¯¹é‚»å±…èŠ‚ç‚¹ä¹Ÿè¿›è¡Œæ’åºä»¥ç¡®ä¿DFSé¡ºåºç¨³å®š
                            const sortedNeighbors = Array.from(neighbors).sort((a, b) => a.localeCompare(b));
                            sortedNeighbors.forEach(nb => {
                                if (!visited.has(nb)) {
                                    visited.add(nb);
                                    stack.push(nb);
                                }
                            });
                        }
                        if (comp.length) components.push(comp);
                    });

                    if (components.length < 2) return;

                    // ä¼°ç®—æ¯ä¸ªç»„ä»¶åŠå¾„
                    const compMeta = components.map(list => {
                        const r = list.reduce((max, n) => Math.max(max, approxRadius(n)), 30);
                        const extra = Math.max(0, list.length - 6) * 6;
                        return { nodes: list, radius: r + extra };
                    });

                    const perim = compMeta.reduce((sum, c) => sum + c.radius * 2, 0);
                    const gap = 100;
                    const orbit = Math.min(
                        Math.max(240, (perim + gap * compMeta.length) / (2 * Math.PI)),
                        520 // ä¸è¦é£å¾—å¤ªè¿œ
                    );

                    let angle = -Math.PI / 2;
                    const angleStep = (Math.PI * 2) / compMeta.length;
                    compMeta.forEach(meta => {
                        const cx = center.x + orbit * Math.cos(angle);
                        const cy = center.y + orbit * Math.sin(angle);
                        // ç»„ä»¶å†…éƒ¨ä½¿ç”¨ç¡®å®šæ€§åç§»ï¼Œé¿å…å®Œå…¨é‡å ä¸”ä¿è¯æ¯æ¬¡ç”Ÿæˆç›¸åŒ
                        meta.nodes.forEach((n, idx) => {
                            const hash = deterministicHash(n.id, seed);
                            const offsetX = deterministicRandom(hash, seed) * Math.max(40, meta.radius * 0.4);
                            const offsetY = deterministicRandom(hash + 1000, seed) * Math.max(40, meta.radius * 0.4);
                            n.x = cx + offsetX;
                            n.y = cy + offsetY;
                        });
                        angle += angleStep;
                    });
                };

                // å°†äº’ä¸ç›¸è¿çš„ç»„ä»¶åˆ†æ•£åˆ°ä¸­å¿ƒå‘¨å›´ï¼Œé¿å…é¦–å±äº¤å‰
                const spreadDisconnectedComponents = (graph, onFinish) => {
                    if (!graph || graph.destroyed) {
                        if (onFinish) onFinish();
                        return;
                    }
                    const nodes = graph.getNodes();
                    if (nodes.length < 2) {
                        if (onFinish) onFinish();
                        return;
                    }

                    // å»ºç«‹æ— å‘é‚»æ¥è¡¨
                    const adj = new Map();
                    graph.getEdges().forEach(edge => {
                        const { source, target } = edge.getModel();
                        if (!adj.has(source)) adj.set(source, new Set());
                        if (!adj.has(target)) adj.set(target, new Set());
                        adj.get(source).add(target);
                        adj.get(target).add(source);
                    });

                    // DFS æ‹†å‡ºç»„ä»¶ï¼ˆæŒ‰IDæ’åºä»¥ç¡®ä¿ç¨³å®šæ€§ï¼‰
                    const visited = new Set();
                    const components = [];
                    const sortedNodes = [...nodes].sort((a, b) => a.getModel().id.localeCompare(b.getModel().id));
                    sortedNodes.forEach(node => {
                        const id = node.getModel().id;
                        if (visited.has(id)) return;
                        const stack = [id];
                        const comp = [];
                        visited.add(id);
                        while (stack.length) {
                            const cur = stack.pop();
                            const curNode = graph.findById(cur);
                            if (curNode) comp.push(curNode);
                            const neighbors = adj.get(cur);
                            if (!neighbors) continue;
                            // å¯¹é‚»å±…èŠ‚ç‚¹ä¹Ÿè¿›è¡Œæ’åºä»¥ç¡®ä¿DFSé¡ºåºç¨³å®š
                            const sortedNeighbors = Array.from(neighbors).sort((a, b) => a.localeCompare(b));
                            sortedNeighbors.forEach(nid => {
                                if (!visited.has(nid)) {
                                    visited.add(nid);
                                    stack.push(nid);
                                }
                            });
                        }
                        if (comp.length) components.push(comp);
                    });

                    if (components.length < 2) {
                        if (onFinish) onFinish();
                        return; // åªæœ‰ä¸€ä¸ªè¿é€šå—æ— éœ€åˆ†æ•£
                    }

                    const diagramCenter = {
                        x: graph.get('width') / 2,
                        y: graph.get('height') / 2
                    };

                    const targets = new Map();

                    // ç»„ä»¶çš„å¤§å°ä¸åŠå¾„
                    const compMeta = components.map(comp => {
                        let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
                        let cx = 0, cy = 0;
                        comp.forEach(n => {
                            const bbox = n.getBBox();
                            minX = Math.min(minX, bbox.minX);
                            maxX = Math.max(maxX, bbox.maxX);
                            minY = Math.min(minY, bbox.minY);
                            maxY = Math.max(maxY, bbox.maxY);
                            cx += bbox.centerX;
                            cy += bbox.centerY;
                        });
                        const width = Math.max(40, maxX - minX);
                        const height = Math.max(40, maxY - minY);
                        const radius = Math.sqrt(width * width + height * height) / 2 + 40; // é¢å¤–ç•™ç™½
                        const center = {
                            x: cx / comp.length,
                            y: cy / comp.length
                        };
                        return { comp, radius, center };
                    });

                    // æ ¹æ®å‘¨é•¿åˆ†é…è§’åº¦ï¼ŒåŠå¾„è¶³å¤Ÿå¤§é¿å…äº’ç›¸ç©¿æ’
                    const gap = 50;
                    const totalSpan = compMeta.reduce((sum, c) => sum + c.radius * 2 + gap, 0);
                    const orbitRadius = Math.min(
                        Math.max(
                            totalSpan / (2 * Math.PI),
                            Math.max(...compMeta.map(c => c.radius)) + gap + 40,
                            240
                        ),
                        520
                    );

                    let angleCursor = -Math.PI / 2;
                    compMeta.forEach(meta => {
                        const angleSpan = ((meta.radius * 2 + gap) / totalSpan) * Math.PI * 2;
                        const midAngle = angleCursor + angleSpan / 2;

                        // å°†ç»„ä»¶æ•´ä½“ç§»åŠ¨åˆ°ç¯å½¢ä½ç½®ï¼Œå¹¶æ—‹è½¬åˆ°åˆ‡å‘æ–¹å‘ï¼Œé¿å…â€œç©¿è¿‡ä¸­å¿ƒâ€çš„ç›´çº¿
                        const targetCenter = {
                            x: diagramCenter.x + orbitRadius * Math.cos(midAngle),
                            y: diagramCenter.y + orbitRadius * Math.sin(midAngle)
                        };
                        const rotateAngle = midAngle + Math.PI / 2;
                        const cosA = Math.cos(rotateAngle);
                        const sinA = Math.sin(rotateAngle);

                        meta.comp.forEach(node => {
                            const m = node.getModel();
                            const relX = m.x - meta.center.x;
                            const relY = m.y - meta.center.y;
                            const rx = relX * cosA - relY * sinA;
                            const ry = relX * sinA + relY * cosA;
                            targets.set(m.id, {
                                x: targetCenter.x + rx,
                                y: targetCenter.y + ry
                            });
                        });

                        angleCursor += angleSpan;
                    });

                    animateNodesToTargets(graph, targets, 450, onFinish);
                };

                const handleGenerate = () => {
                    try {
                        setError(null);
                        setLoading(true);

                        if (!inputText.trim()) {
                            setError("è¾“å…¥ä¸ºç©ºã€‚");
                            setLoading(false);
                            return;
                        }

                        // å¦‚æœè¾“å…¥æ”¹å˜äº†ï¼Œè®°å½•æ–°è¾“å…¥
                        if (lastInputRef.current !== inputText.trim()) {
                            lastInputRef.current = inputText.trim();
                        }

                        let parsedData;
                        const potentialSQL = inputText.trim();

                        // Try parsing as SQL first, if it fails (no tables), try DBML.
                        parsedData = parseSQLTables(potentialSQL);

                        if (parsedData.tables.length === 0) {
                            parsedData = parseDBML(potentialSQL);
                        }

                        const { tables, relationships } = parsedData;

                        if (tables.length === 0) {
                            setError("æœªæ‰¾åˆ°æœ‰æ•ˆçš„ CREATE TABLE æˆ– Table å®šä¹‰ã€‚è¯·ç¡®ä¿æ‚¨çš„SQLæˆ–DBMLè¯­æ³•æ­£ç¡®ã€‚");
                            setLoading(false);
                            return;
                        }

                        const { nodes, edges } = generateChenModelData(tables, relationships, isColored);

                        // åˆå§‹ä½ç½®ï¼šå…ˆæŠŠä¸åŒç»„ä»¶åˆ†å¼€å›´ç»•ä¸­å¿ƒï¼Œé¿å…åˆå§‹äº¤å‰
                        applyInitialComponentPositions(nodes, edges, containerRef.current, 0);

                        // Clear previous graph completely
                        if (graphRef.current) {
                            graphRef.current.clear(); // å…ˆæ¸…ç©ºæ•°æ®
                            graphRef.current.destroy(); // å†é”€æ¯å›¾å½¢
                            graphRef.current = null; // é‡ç½®å¼•ç”¨
                        }

                        // Create G6 graph
                        const graph = new G6.Graph({
                            container: containerRef.current,
                            width: containerRef.current.offsetWidth,
                            height: containerRef.current.offsetHeight,
                            renderer: 'canvas',
                            background: '#ffffff', // è®¾ç½®ç™½è‰²èƒŒæ™¯ï¼Œç¡®ä¿å¤åˆ¶å›¾ç‰‡æ—¶èƒŒæ™¯ä¸ºç™½è‰²
                            modes: {
                                default: [
                                    'drag-node',                         // 1. å…ˆåˆ¤æ–­æ‹–èŠ‚ç‚¹
                                    {
                                        type: 'drag-canvas',
                                        allowDragOnItem: true,             // 2. å…è®¸åœ¨ item ä¸Šæ‹–ç”»å¸ƒ
                                        enableOptimize: false,              //    ï¼ˆæ€§èƒ½ä¼˜åŒ–ï¼Œå¯ç•™å¯åˆ ï¼‰
                                        shouldBegin(e) {                   // 3. è‡ªå®šä¹‰å¼€å§‹æ¡ä»¶
                                            // e.item ä¸ºç©º = çœŸç©ºç™½å¤„ï¼›ç»„åˆ / è¾¹ä¹Ÿç®—"é node"
                                            return !e.item || e.item.getType() !== 'node';
                                        }
                                    },
                                    'zoom-canvas'
                                ]
                            },

                            // ä¼˜åŒ–åçš„åŠ›å¯¼å‘å¸ƒå±€é…ç½®ï¼Œä»¥å®Œå…¨é¿å…é‡å 
                            layout: {
                                type: 'force2', // ä½¿ç”¨ force2 å¸ƒå±€
                                preventOverlap: true, // ç¡®ä¿èŠ‚ç‚¹ä¸é‡å 
                                // å¿½ç•¥æ–‡æœ¬é•¿åº¦ï¼Œç»Ÿä¸€å¤„ç†æ¤­åœ†/è±å½¢å°ºå¯¸ï¼Œé¿å…å› å†…å®¹é•¿çŸ­é€ æˆå¸ƒå±€åå·®
                                nodeSize: (node) => {
                                    const uniformSizes = {
                                        entity: 140,
                                        relationship: 90,
                                        attribute: 90
                                    };
                                    return uniformSizes[node.nodeType] || 90;
                                },
                                nodeSpacing: 20,     // å¢åŠ èŠ‚ç‚¹é—´è·
                                linkDistance: 120,   // è¿çº¿é•¿åº¦
                                // force2 ç‰¹å®šå‚æ•°
                                coulombDisScale: 0.005,  // åº“ä»‘åŠ›çš„ç¼©æ”¾å› å­
                                damping: 0.9,            // é˜»å°¼ç³»æ•°
                                maxSpeed: 1000,          // æœ€å¤§é€Ÿåº¦
                                minMovement: 0.5,        // æœ€å°ç§»åŠ¨é‡
                                interval: 0.02,          // è¿­ä»£é—´éš”
                                factor: 1,               // æ–¥åŠ›å› å­
                                maxIteration: 800,       // æœ€å¤§è¿­ä»£æ¬¡æ•°
                                animate: true,           // å¯ç”¨åŠ¨ç”»ä»¥æ˜¾ç¤ºå¸ƒå±€è¿‡ç¨‹
                                center: [containerRef.current.offsetWidth / 2, 300], // å¸ƒå±€ä¸­å¿ƒ
                                clustering: false,       // ä¸ä½¿ç”¨èšç±»
                                tick: () => {
                                    // é€å¸§åˆ·æ–°ä»¥å±•ç°è‡ªåŠ¨è°ƒæ•´è¿‡ç¨‹
                                    graph.refreshPositions();
                                },
                                onLayoutEnd: () => {
                                    // å…ˆè®©äº’ä¸ç›¸è¿çš„ç»„ä»¶ç¯ç»•åˆ†å¸ƒï¼Œé¿å…åå­—äº¤å‰
                                    setTimeout(() => {
                                        if (graphRef.current && !graphRef.current.destroyed) {
                                            spreadDisconnectedComponents(graphRef.current, () => {
                                                // å¸ƒå±€å®Œæˆåå¹³æ»‘è°ƒæ•´è§†å›¾
                                                smoothFitView(graphRef.current, 800, 'easeOutCubic');
                                            });
                                        }
                                    }, 30);
                                }
                            },
                            defaultNode: {
                                style: {
                                    lineWidth: 2,
                                    stroke: '#000',
                                    fill: '#fff'
                                },
                                labelCfg: {
                                    style: {
                                        fill: '#000',
                                        fontSize: 16  // ä»12å¢åŠ åˆ°16
                                    }
                                }
                            },
                            defaultEdge: {
                                style: {
                                    lineWidth: 1,
                                    stroke: '#000000'
                                },
                                labelCfg: {
                                    style: {
                                        fill: '#000000',
                                        fontSize: 14,  // ä»10å¢åŠ åˆ°14
                                        background: {
                                            fill: '#fff',
                                            padding: [2, 4, 2, 4]
                                        }
                                    }
                                }
                            },
                            edgeStateStyles: {
                                hover: {
                                    stroke: '#1890ff',
                                    lineWidth: 2
                                }
                            },
                            defaultEdgeConfig: {
                                type: 'cubic-horizontal',
                                router: {
                                    name: 'orthogonal',
                                    args: {
                                        offset: 25,
                                        maxTurns: 5,
                                        useMaxTurns: false,
                                        gridSize: 1
                                    }
                                },
                                connector: {
                                    name: 'curve',
                                    args: {
                                        curveType: 'cubic-horizontal',
                                        curveOffset: 50
                                    }
                                }
                            },
                            nodeStateStyles: {
                                hover: {
                                    fill: '#e6f7ff',
                                    stroke: '#1890ff'
                                }
                            }
                        });

                        graphRef.current = graph;
                        setHasGraph(true); // æ ‡è®°å›¾å½¢å·²ç”Ÿæˆ

                        // Set data and render
                        graph.data({ nodes, edges });
                        graph.render();

                        // åº”ç”¨åˆå§‹æ ·å¼
                        updateGraphStyles(graph, isColored);

                        // åˆå§‹æ¸²æŸ“åä½¿ç”¨å¹³æ»‘åŠ¨ç”»è°ƒæ•´è§†å›¾
                        setTimeout(() => {
                            smoothFitView(graph, 600, 'easeOutQuart');
                        }, 200);

                        // Enable interactions
                        graph.on('node:mouseenter', (e) => {
                            graph.setItemState(e.item, 'hover', true);
                        });

                        graph.on('node:mouseleave', (e) => {
                            graph.setItemState(e.item, 'hover', false);
                        });

                        // æ·»åŠ åŒå‡»ç¼–è¾‘åŠŸèƒ½
                        let editingNode = null;
                        let editInput = null;

                        graph.on('node:dblclick', (e) => {
                            const node = e.item;
                            const model = node.getModel();

                            // é˜²æ­¢é‡å¤ç¼–è¾‘
                            if (editingNode) {
                                finishEditing(false);
                            }

                            startEditing(node, model);
                        });

                        // å¼€å§‹ç¼–è¾‘èŠ‚ç‚¹
                        const startEditing = (node, model) => {
                            editingNode = node;
                            // `getCanvasByPoint` è¿”å›çš„æ˜¯ç›¸å¯¹äº G6 ç”»å¸ƒå·¦ä¸Šè§’çš„åæ ‡
                            const canvasPoint = graph.getCanvasByPoint(model.x, model.y);
                            // è·å–å½“å‰ç¼©æ”¾æ¯”ä¾‹
                            const currentZoom = graph.getZoom();

                            // æ ¹æ®èŠ‚ç‚¹ç±»å‹è®¡ç®—è¾“å…¥æ¡†çš„å°ºå¯¸å’Œä½ç½®
                            const getNodeDimensions = (nodeModel) => {
                                const text = nodeModel.label || '';
                                const getTextWidth = (text, fontSize) => {
                                    let width = 0;
                                    for (let char of text) {
                                        if (/[\u4e00-\u9fa5]/.test(char)) {
                                            width += fontSize;
                                        } else {
                                            width += fontSize * 0.6;
                                        }
                                    }
                                    return width;
                                };

                                let width, height, fontSize;

                                if (nodeModel.type === 'entity') {
                                    fontSize = 18;
                                    const textWidth = getTextWidth(text, fontSize);
                                    width = Math.max(80, textWidth + 20);
                                    height = Math.max(50, fontSize + 20);
                                } else if (nodeModel.type === 'relationship') {
                                    fontSize = 16;
                                    const textWidth = getTextWidth(text, fontSize);
                                    const horizontalPadding = 24;
                                    const minWidth = 80;
                                    const requiredWidth = textWidth + horizontalPadding * 2;
                                    const halfWidth = Math.max(minWidth / 2, requiredWidth / 2);
                                    width = halfWidth * 2;
                                    height = Math.max(40, Math.min(halfWidth * 0.6, fontSize + 16) * 2);
                                } else { // attribute
                                    fontSize = 15;
                                    const textWidth = getTextWidth(text, fontSize);
                                    width = Math.max(60, textWidth + 32);
                                    height = Math.max(40, fontSize + 16);
                                }

                                return { width, height, fontSize };
                            };

                            const dimensions = getNodeDimensions(model);
                            // åº”ç”¨ç¼©æ”¾åˆ°è¾“å…¥æ¡†å°ºå¯¸å’Œå­—ä½“
                            const scaledWidth = dimensions.width * currentZoom;
                            const scaledHeight = dimensions.height * currentZoom;
                            const scaledFontSize = dimensions.fontSize * currentZoom;

                            // æ ¹æ®èŠ‚ç‚¹ç±»å‹è·å–å¯¹åº”çš„é¢œè‰²
                            const getNodeColor = (nodeModel) => {
                                if (nodeModel.type === 'entity') {
                                    return '#0ea5e9'; // è“è‰²
                                } else if (nodeModel.type === 'relationship') {
                                    return '#722ed1'; // ç´«è‰²
                                } else if (nodeModel.type === 'attribute') {
                                    return nodeModel.keyType === 'pk' ? '#10b981' : '#94a3b8'; // ç»¿è‰²æˆ–ç°è‰²
                                }
                                return '#ff8a65'; // é»˜è®¤æ©™è‰²
                            };

                            const borderColor = getNodeColor(model);
                            const shadowColor = borderColor.replace('#', 'rgba(') + ', 0.2)'.replace('rgba(', 'rgba(').replace(', 0.2)', ')');
                            const rgbValues = borderColor.substring(1).match(/.{1,2}/g).map(x => parseInt(x, 16));
                            const shadowColorRGB = `rgba(${rgbValues.join(', ')}, 0.2)`;

                            // åˆ›å»ºè¾“å…¥æ¡†
                            editInput = document.createElement('input');
                            editInput.type = 'text';
                            editInput.value = model.label || '';
                            editInput.style.position = 'absolute';
                            // å®šä½æ˜¯ç›¸å¯¹äº G6 çš„å®¹å™¨ (containerRef.current)
                            editInput.style.left = (canvasPoint.x - scaledWidth / 2) + 'px';
                            editInput.style.top = (canvasPoint.y - scaledHeight / 2) + 'px';
                            editInput.style.width = scaledWidth + 'px';
                            editInput.style.height = scaledHeight + 'px';
                            editInput.style.padding = '0';
                            editInput.style.border = `${2 * currentZoom}px solid ${borderColor}`;
                            editInput.style.outline = 'none';
                            editInput.style.fontSize = scaledFontSize + 'px';
                            editInput.style.textAlign = 'center';
                            editInput.style.backgroundColor = 'rgba(255, 255, 255, 0.95)';
                            editInput.style.zIndex = '1000';
                            editInput.style.boxShadow = `0 0 0 ${3 * currentZoom}px ${shadowColorRGB}`;
                            editInput.style.fontWeight = (model.type === 'entity' || model.keyType === 'pk') ? 'bold' : 'normal';

                            // æ ¹æ®èŠ‚ç‚¹ç±»å‹è®¾ç½®è¾¹æ¡†æ ·å¼
                            if (model.type === 'entity') {
                                editInput.style.borderRadius = (4 * currentZoom) + 'px';
                            } else if (model.type === 'relationship') {
                                editInput.style.borderRadius = (8 * currentZoom) + 'px';
                                // è±å½¢èŠ‚ç‚¹ç”¨çŸ©å½¢è¾“å…¥æ¡†ï¼Œä¸æ—‹è½¬ä»¥ä¾¿äºç¼–è¾‘
                            } else { // attribute
                                editInput.style.borderRadius = '50%';
                            }

                            // å°†è¾“å…¥æ¡†é™„åŠ åˆ° G6 çš„å®¹å™¨ä¸­
                            containerRef.current.appendChild(editInput);
                            editInput.focus();
                            editInput.select();

                            // ç›‘å¬é”®ç›˜äº‹ä»¶
                            editInput.addEventListener('keydown', (e) => {
                                if (e.key === 'Enter') {
                                    finishEditing(true);
                                    e.preventDefault();
                                } else if (e.key === 'Escape') {
                                    finishEditing(false);
                                    e.preventDefault();
                                }
                            });

                            // ç›‘å¬å¤±å»ç„¦ç‚¹äº‹ä»¶
                            editInput.addEventListener('blur', () => {
                                setTimeout(() => finishEditing(true), 100);
                            });
                        };

                        // å®Œæˆç¼–è¾‘
                        const finishEditing = (save) => {
                            if (!editingNode || !editInput) return;

                            if (save && editInput.value.trim()) {
                                const newLabel = editInput.value.trim();
                                const model = editingNode.getModel();

                                // æ›´æ–°èŠ‚ç‚¹æ ‡ç­¾
                                graph.updateItem(editingNode, {
                                    label: newLabel
                                });

                                // å¦‚æœæ˜¯å±æ€§èŠ‚ç‚¹ï¼Œå¯èƒ½éœ€è¦æ›´æ–°ç›¸å…³çš„æ•°æ®ç»“æ„
                                if (model.type === 'attribute') {
                                    // å¯ä»¥åœ¨è¿™é‡Œæ·»åŠ é¢å¤–çš„æ•°æ®åŒæ­¥é€»è¾‘
                                    console.log(`å±æ€§ ${model.label} å·²æ›´æ–°ä¸º ${newLabel}`);
                                } else if (model.type === 'entity') {
                                    console.log(`å®ä½“ ${model.label} å·²æ›´æ–°ä¸º ${newLabel}`);
                                } else if (model.type === 'relationship') {
                                    console.log(`å…³ç³» ${model.label} å·²æ›´æ–°ä¸º ${newLabel}`);
                                }
                            }

                            // æ¸…ç†ç¼–è¾‘çŠ¶æ€
                            if (editInput && editInput.parentNode) {
                                editInput.parentNode.removeChild(editInput);
                            }
                            editInput = null;
                            editingNode = null;
                        };

                        // ç‚¹å‡»ç”»å¸ƒå…¶ä»–åœ°æ–¹ä¹Ÿç»“æŸç¼–è¾‘
                        graph.on('canvas:click', () => {
                            if (editingNode) {
                                finishEditing(true);
                            }
                        });

                        // è‡ªå®šä¹‰æ‹–æ‹½é€»è¾‘ï¼šæ‹–åŠ¨å®ä½“æ—¶å¸¦åŠ¨ç›¸å…³å±æ€§ä¸€èµ·ç§»åŠ¨
                        let draggedEntity = null;
                        let relatedAttributes = [];
                        let dragStartPositions = new Map();

                        graph.on('node:dragstart', (e) => {
                            const node = e.item;
                            const nodeModel = node.getModel();

                            // åªå¤„ç†å®ä½“èŠ‚ç‚¹çš„æ‹–æ‹½
                            if (nodeModel.type === 'entity') {
                                draggedEntity = node;
                                relatedAttributes = [];
                                dragStartPositions.clear();

                                // è®°å½•å®ä½“çš„åˆå§‹ä½ç½®
                                dragStartPositions.set(nodeModel.id, { x: nodeModel.x, y: nodeModel.y });

                                // æ‰¾åˆ°æ‰€æœ‰ç›¸å…³çš„å±æ€§èŠ‚ç‚¹
                                const allNodes = graph.getNodes();
                                allNodes.forEach(n => {
                                    const model = n.getModel();
                                    if (model.type === 'attribute' && model.parentEntity === nodeModel.id) {
                                        relatedAttributes.push(n);
                                        // è®°å½•å±æ€§çš„åˆå§‹ä½ç½®
                                        dragStartPositions.set(model.id, { x: model.x, y: model.y });
                                    }
                                });
                            }
                        });

                        graph.on('node:drag', (e) => {
                            const node = e.item;
                            const nodeModel = node.getModel();

                            // åªå¤„ç†å®ä½“èŠ‚ç‚¹çš„æ‹–æ‹½
                            if (nodeModel.type === 'entity' && draggedEntity === node) {
                                const currentPos = { x: nodeModel.x, y: nodeModel.y };
                                const startPos = dragStartPositions.get(nodeModel.id);

                                if (startPos) {
                                    // è®¡ç®—å®ä½“çš„ç§»åŠ¨è·ç¦»
                                    const deltaX = currentPos.x - startPos.x;
                                    const deltaY = currentPos.y - startPos.y;

                                    // åŒæ­¥ç§»åŠ¨æ‰€æœ‰ç›¸å…³çš„å±æ€§èŠ‚ç‚¹
                                    relatedAttributes.forEach(attrNode => {
                                        const attrModel = attrNode.getModel();
                                        const attrStartPos = dragStartPositions.get(attrModel.id);

                                        if (attrStartPos) {
                                            const newX = attrStartPos.x + deltaX;
                                            const newY = attrStartPos.y + deltaY;

                                            // æ›´æ–°å±æ€§èŠ‚ç‚¹ä½ç½®
                                            graph.updateItem(attrNode, { x: newX, y: newY });
                                        }
                                    });
                                }
                            }
                        });

                        graph.on('node:dragend', (e) => {
                            const node = e.item;
                            const nodeModel = node.getModel();

                            // æ¸…ç†æ‹–æ‹½çŠ¶æ€
                            if (nodeModel.type === 'entity' && draggedEntity === node) {
                                draggedEntity = null;
                                relatedAttributes = [];
                                dragStartPositions.clear();
                            }
                        });

                        // è‡ªåŠ¨å¸ƒå±€è¯´æ˜ï¼š
                        // 1. forceå¸ƒå±€ä¼šè‡ªåŠ¨è®¡ç®—èŠ‚ç‚¹ä½ç½®ï¼Œé¿å…é‡å 
                        // 2. ä¸åŒç±»å‹èŠ‚ç‚¹æœ‰ä¸åŒçš„æ’æ–¥åŠ›å’Œé—´è·
                        // 3. è¿çº¿é•¿åº¦æ ¹æ®å…³ç³»ç±»å‹è‡ªåŠ¨è°ƒæ•´
                        // 4. å¸ƒå±€å®Œæˆåè‡ªåŠ¨è°ƒæ•´è§†å›¾å¤§å°

                    } catch (e) {
                        console.error("SQL Parsing error:", e);
                        setError(`SQL è§£æå¤±è´¥: ${e.message}. è¯·æ£€æŸ¥SQLè¯­æ³•æ˜¯å¦æ­£ç¡®ã€‚`);
                    } finally {
                        setLoading(false);
                    }
                };

                useEffect(() => {
                    handleGenerate();

                    // Cleanup on unmount
                    return () => {
                        if (graphRef.current) {
                            graphRef.current.destroy();
                        }
                    };
                }, []);

                const handleResize = () => {
                    if (graphRef.current && containerRef.current) {
                        graphRef.current.changeSize(
                            containerRef.current.offsetWidth,
                            containerRef.current.offsetHeight
                        );
                    }
                };

                // å¯¼å‡ºSVGåŠŸèƒ½
                const handleExportSVG = () => {
                    if (!graphRef.current || !hasGraph) {
                        setError('è¯·å…ˆç”ŸæˆERå›¾');
                        return;
                    }

                    try {
                        // è·å–å½“å‰å›¾å½¢æ•°æ®ï¼ŒåŒ…æ‹¬èŠ‚ç‚¹çš„å®é™…ä½ç½®
                        const data = graphRef.current.save();

                        // åˆ›å»ºä¸€ä¸ªä¸´æ—¶å®¹å™¨
                        const tempContainer = document.createElement('div');
                        tempContainer.style.position = 'absolute';
                        tempContainer.style.left = '-9999px';
                        tempContainer.style.top = '-9999px';
                        document.body.appendChild(tempContainer);

                        // åˆ›å»ºä¸´æ—¶SVGå›¾å½¢ï¼Œä½¿ç”¨ç›¸åŒçš„é…ç½®
                        const tempGraph = new G6.Graph({
                            container: tempContainer,
                            width: containerRef.current.offsetWidth,
                            height: 600,
                            renderer: 'svg',
                            modes: {
                                default: []
                            },
                            // ä¸ä½¿ç”¨å¸ƒå±€ï¼Œç›´æ¥ä½¿ç”¨ä¿å­˜çš„ä½ç½®
                            layout: null,
                            defaultNode: {
                                style: {
                                    lineWidth: 2,
                                    stroke: '#000',
                                    fill: '#fff'
                                },
                                labelCfg: {
                                    style: {
                                        fill: '#000',
                                        fontSize: 16
                                    }
                                }
                            },
                            defaultEdge: {
                                style: {
                                    lineWidth: 1,
                                    stroke: '#000'
                                },
                                labelCfg: {
                                    style: {
                                        fill: '#000',
                                        fontSize: 14,
                                        background: {
                                            fill: '#fff',
                                            padding: [2, 4, 2, 4]
                                        }
                                    }
                                }
                            },
                            edgeStateStyles: {
                                hover: {
                                    stroke: '#1890ff',
                                    lineWidth: 2
                                }
                            },
                            defaultEdgeConfig: {
                                type: 'cubic-horizontal',
                                router: {
                                    name: 'orthogonal',
                                    args: {
                                        offset: 25,
                                        maxTurns: 5,
                                        useMaxTurns: false,
                                        gridSize: 1
                                    }
                                },
                                connector: {
                                    name: 'curve',
                                    args: {
                                        curveType: 'cubic-horizontal',
                                        curveOffset: 50
                                    }
                                }
                            }
                        });

                        // è¯»å–å½“å‰å›¾å½¢æ•°æ®ï¼ˆåŒ…å«èŠ‚ç‚¹ä½ç½®ï¼‰
                        tempGraph.read(data);

                        // ç­‰å¾…æ¸²æŸ“å®Œæˆ
                        setTimeout(() => {
                            try {
                                const tempCanvas = tempGraph.get('canvas');
                                const svgElement = tempCanvas.get('el');

                                // å…‹éš†SVGå…ƒç´ ä»¥é¿å…ä¿®æ”¹åŸå§‹å…ƒç´ 
                                const clonedSvg = svgElement.cloneNode(true);

                                // è·å–æ‰€æœ‰å›¾å½¢çš„è¾¹ç•Œæ¡†
                                const group = tempGraph.getGroup();
                                const bbox = group.getCanvasBBox();

                                // æ·»åŠ padding
                                const padding = 40;
                                const viewBoxX = bbox.minX - padding;
                                const viewBoxY = bbox.minY - padding;
                                const viewBoxWidth = bbox.width + padding * 2;
                                const viewBoxHeight = bbox.height + padding * 2;

                                // è®¾ç½®SVGå±æ€§ä»¥åŒ…å«å®Œæ•´å†…å®¹
                                clonedSvg.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
                                clonedSvg.setAttribute('width', viewBoxWidth);
                                clonedSvg.setAttribute('height', viewBoxHeight);
                                clonedSvg.setAttribute('viewBox', `${viewBoxX} ${viewBoxY} ${viewBoxWidth} ${viewBoxHeight}`);

                                // è®¾ç½®ç™½è‰²èƒŒæ™¯ï¼Œä½¿ç”¨viewBoxçš„å°ºå¯¸
                                const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                                rect.setAttribute('x', viewBoxX);
                                rect.setAttribute('y', viewBoxY);
                                rect.setAttribute('width', viewBoxWidth);
                                rect.setAttribute('height', viewBoxHeight);
                                rect.setAttribute('fill', '#ffffff');
                                clonedSvg.insertBefore(rect, clonedSvg.firstChild);

                                const svgString = new XMLSerializer().serializeToString(clonedSvg);
                                downloadSVG(svgString, 'er-diagram.svg');

                                // æ¸…ç†ä¸´æ—¶å›¾å½¢å’Œå®¹å™¨
                                tempGraph.destroy();
                                document.body.removeChild(tempContainer);
                            } catch (innerError) {
                                console.error('SVGç”Ÿæˆå¤±è´¥:', innerError);
                                setError('SVGç”Ÿæˆå¤±è´¥: ' + innerError.message);
                                tempGraph.destroy();
                                if (tempContainer.parentNode) {
                                    document.body.removeChild(tempContainer);
                                }
                            }
                        }, 1000); // å¢åŠ ç­‰å¾…æ—¶é—´ç¡®ä¿æ¸²æŸ“å®Œæˆ
                    } catch (error) {
                        console.error('å¯¼å‡ºSVGå¤±è´¥:', error);
                        setError('å¯¼å‡ºSVGå¤±è´¥: ' + error.message);
                    }
                };

                // ä¸‹è½½SVGæ–‡ä»¶
                const downloadSVG = (svgString, filename) => {
                    const blob = new Blob([svgString], { type: 'image/svg+xml' });
                    const url = URL.createObjectURL(blob);
                    const link = document.createElement('a');
                    link.href = url;
                    link.download = filename;
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    URL.revokeObjectURL(url);
                };

                useEffect(() => {
                    window.addEventListener('resize', handleResize);
                    return () => window.removeEventListener('resize', handleResize);
                }, []);

                // åˆ‡æ¢èƒŒæ™¯æ˜¾ç¤º
                const handleToggleBackground = () => {
                    setShowBackground(!showBackground);
                };

                // å¼ºåˆ¶å¯¹é½ï¼šæœ€é•¿é“¾æ°´å¹³ï¼Œæ”¯é“¾é€’å½’æ‹‰ç›´ï¼ˆçŸ©å½¢+è±å½¢ï¼‰ï¼Œç»„ä»¶åˆ†éš”é¿å…é‡å 
                const handleForceAlign = () => {
                    if (!graphRef.current || graphRef.current.destroyed) return;
                    const graph = graphRef.current;
                    const allNodes = graph.getNodes();
                    if (!allNodes.length) return;

                    const carbonNodes = allNodes.filter(n => {
                        const t = n.getModel().nodeType;
                        return t === 'entity' || t === 'relationship';
                    });
                    if (!carbonNodes.length) return;

                    const container = containerRef.current;
                    const canvasWidth = container?.offsetWidth || 1200;
                    const componentGap = 160;

                    const nodeMap = new Map();
                    allNodes.forEach(n => nodeMap.set(n.getModel().id, n));

                    const getRadius = (node) => {
                        const b = node.getBBox();
                        return Math.sqrt(b.width * b.width + b.height * b.height) / 2;
                    };

                    const normalizeAngle = (a) => {
                        let ang = a % (Math.PI * 2);
                        if (ang < 0) ang += Math.PI * 2;
                        return ang;
                    };

                    // æ„å»ºä»…åŒ…å«çŸ©å½¢/è±å½¢çš„é‚»æ¥è¡¨
                    const carbonAdj = new Map();
                    graph.getEdges().forEach(e => {
                        const { source, target } = e.getModel();
                        const sNode = nodeMap.get(source);
                        const tNode = nodeMap.get(target);
                        if (!sNode || !tNode) return;
                        const sType = sNode.getModel().nodeType;
                        const tType = tNode.getModel().nodeType;
                        if ((sType === 'entity' || sType === 'relationship') && (tType === 'entity' || tType === 'relationship')) {
                            if (!carbonAdj.has(source)) carbonAdj.set(source, new Set());
                            if (!carbonAdj.has(target)) carbonAdj.set(target, new Set());
                            carbonAdj.get(source).add(target);
                            carbonAdj.get(target).add(source);
                        }
                    });

                    if (!carbonAdj.size) return;

                    // è®¡ç®—ç¢³å›¾ç»„ä»¶
                    const carbonIds = carbonNodes.map(n => n.getModel().id);
                    const visited = new Set();
                    const components = [];
                    carbonIds.forEach(id => {
                        if (visited.has(id)) return;
                        const stack = [id];
                        const comp = [];
                        visited.add(id);
                        while (stack.length) {
                            const cur = stack.pop();
                            comp.push(cur);
                            const neighbors = carbonAdj.get(cur);
                            if (!neighbors) continue;
                            neighbors.forEach(nb => {
                                if (!visited.has(nb)) {
                                    visited.add(nb);
                                    stack.push(nb);
                                }
                            });
                        }
                        components.push(comp);
                    });

                    // å®ä½“çš„å±æ€§èŠ‚ç‚¹æ˜ å°„
                    const entityAttrs = new Map();
                    allNodes.forEach(n => {
                        const m = n.getModel();
                        if (m.nodeType === 'attribute' && m.parentEntity) {
                            if (!entityAttrs.has(m.parentEntity)) entityAttrs.set(m.parentEntity, []);
                            entityAttrs.get(m.parentEntity).push(n);
                        }
                    });

                    const bfsWithin = (start, allowedSet) => {
                        const dist = new Map();
                        const prev = new Map();
                        const queue = [start];
                        dist.set(start, 0);
                        while (queue.length) {
                            const cur = queue.shift();
                            const neighbors = carbonAdj.get(cur);
                            if (!neighbors) continue;
                            neighbors.forEach(nb => {
                                if (!allowedSet.has(nb) || dist.has(nb)) return;
                                dist.set(nb, dist.get(cur) + 1);
                                prev.set(nb, cur);
                                queue.push(nb);
                            });
                        }
                        return { dist, prev };
                    };

                    const findLongestPath = (ids) => {
                        const allowed = new Set(ids);
                        const start = ids[0];
                        const { dist: distA } = bfsWithin(start, allowed);
                        let farA = start;
                        distA.forEach((d, id) => { if (d > distA.get(farA)) farA = id; });
                        const { dist: distB, prev: prevB } = bfsWithin(farA, allowed);
                        let farB = farA;
                        distB.forEach((d, id) => { if (d > distB.get(farB)) farB = id; });
                        const path = [];
                        let cur = farB;
                        while (cur !== undefined) {
                            path.unshift(cur);
                            cur = prevB.get(cur);
                        }
                        return path.length ? path : [start];
                    };

                    // æ”¶é›†æŸæ¡æ”¯é“¾çš„èŠ‚ç‚¹é›†åˆ
                    const collectBranch = (start, blocked) => {
                        const allowed = new Set();
                        const stack = [start];
                        allowed.add(start);
                        while (stack.length) {
                            const cur = stack.pop();
                            const neighbors = carbonAdj.get(cur);
                            if (!neighbors) continue;
                            neighbors.forEach(nb => {
                                if (blocked.has(nb) || allowed.has(nb)) return;
                                allowed.add(nb);
                                stack.push(nb);
                            });
                        }
                        return allowed;
                    };

                    const computeSpacing = (size) => {
                        // å¤æ‚åº¦è¶Šé«˜ï¼Œé—´è·è¶Šå¤§ï¼Œé¿å…â€œä¸€å¨â€
                        return Math.min(320, 170 + size * 12);
                    };

                    const layoutComponent = (ids) => {
                        const carbonSpacing = computeSpacing(ids.length);
                        const localTargets = new Map();
                        const dirMap = new Map();
                        const allowedSet = new Set(ids);

                        const mainPath = findLongestPath(ids);
                        const mainPathSet = new Set(mainPath);
                        const total = mainPath.length;
                        const startX = -carbonSpacing * (total - 1) / 2;
                        const mainY = 0;
                        mainPath.forEach((id, idx) => {
                            localTargets.set(id, { x: startX + idx * carbonSpacing, y: mainY });
                            dirMap.set(id, { x: 1, y: 0 });
                        });

                        const placed = new Set(mainPath);
                        const queue = [...mainPath];

                        const straightenBranch = (rootId, parentId, angle) => {
                            const blocked = new Set(placed);
                            blocked.add(parentId);
                            const branchSet = collectBranch(rootId, blocked);
                            const path = findLongestPath(Array.from(branchSet));
                            const unit = { x: Math.cos(angle), y: Math.sin(angle) };
                            const parentPos = localTargets.get(parentId);
                            path.forEach((pid, idx) => {
                                const pos = {
                                    x: parentPos.x + unit.x * carbonSpacing * (idx + 1),
                                    y: parentPos.y + unit.y * carbonSpacing * (idx + 1)
                                };
                                localTargets.set(pid, pos);
                                dirMap.set(pid, unit);
                                if (!placed.has(pid)) queue.push(pid);
                                placed.add(pid);
                            });
                        };

                        while (queue.length) {
                            const curId = queue.shift();
                            const curDir = dirMap.get(curId) || { x: 1, y: 0 };
                            const neighbors = carbonAdj.get(curId);
                            if (!neighbors) continue;
                            const unplaced = Array.from(neighbors).filter(id => !placed.has(id));
                            if (!unplaced.length) continue;

                            // å°†æœªæ”¾ç½®é‚»å±…æŒ‰æ”¯é“¾åˆ†ç»„
                            const blockedBase = new Set(placed);
                            blockedBase.add(curId);
                            const seen = new Set();
                            const branches = [];
                            unplaced.forEach(nb => {
                                if (seen.has(nb)) return;
                                const branchNodes = collectBranch(nb, blockedBase);
                                branchNodes.forEach(nid => seen.add(nid));
                                branches.push({ root: nb, nodes: branchNodes, size: branchNodes.size });
                            });

                            // æŒ‰æ”¯é“¾é•¿åº¦æ’åºï¼Œæœ€é•¿ä¼˜å…ˆ
                            branches.sort((a, b) => b.size - a.size);

                            const baseAngle = Math.atan2(curDir.y, curDir.x) + Math.PI / 2;
                            const span = branches.length > 1 ? Math.min(Math.PI * 1.5, Math.PI + (branches.length - 1) * 0.2) : Math.PI / 2;
                            const step = branches.length === 1 ? 0 : span / (branches.length - 1);
                            const start = baseAngle - span / 2;

                            branches.forEach((b, idx) => {
                                const angle = start + step * idx;
                                straightenBranch(b.root, curId, angle);
                            });
                        }

                        // å…œåº•ï¼šä»æœªå¸ƒå±€çš„èŠ‚ç‚¹
                        ids.forEach(id => {
                            if (!localTargets.has(id)) {
                                localTargets.set(id, { x: 0, y: 0 });
                            }
                        });

                        // ç¯ç»•å±æ€§ï¼ˆä¸ç§»åŠ¨è±å½¢ï¼‰ï¼Œè®°å½•ç»„ä»¶è¾¹ç•Œ
                        const entityIds = ids.filter(id => nodeMap.get(id)?.getModel().nodeType === 'entity');
                        entityIds.forEach(eid => {
                            const entityNode = nodeMap.get(eid);
                            const centerPos = localTargets.get(eid);
                            const relNeighbors = Array.from((carbonAdj.get(eid) || new Set()))
                                .filter(id => allowedSet.has(id) && nodeMap.get(id)?.getModel().nodeType === 'relationship');
                            const attrs = entityAttrs.get(eid) || [];
                            const connectors = relNeighbors.length + attrs.length;
                            if (!connectors) return;

                            const inDir = dirMap.get(eid) || { x: 1, y: 0 };
                            const angleStep = (Math.PI * 2) / connectors;

                            // æ§½ä½è§’åº¦å‡åˆ†360Â°
                            const slots = [];
                            for (let i = 0; i < connectors; i++) {
                                slots.push(normalizeAngle(angleStep * i));
                            }

                            // å…³ç³»è§’åº¦ï¼ˆå›ºå®šï¼Œä¸ç§»åŠ¨è±å½¢ï¼‰
                            const relAngles = relNeighbors.map(rid => {
                                const relPos = localTargets.get(rid);
                                if (!relPos) return 0;
                                return normalizeAngle(Math.atan2(relPos.y - centerPos.y, relPos.x - centerPos.x));
                            });

                            const used = new Set();
                            const slotRelMap = new Map(); // slotIdx -> relId

                            // å°†å…³ç³»åˆ†é…åˆ°æœ€è¿‘æ§½ä½
                            relNeighbors.forEach((rid, idx) => {
                                const ang = relAngles[idx];
                                let bestSlot = -1;
                                let bestDiff = Infinity;
                                slots.forEach((slotAng, sIdx) => {
                                    if (used.has(sIdx)) return;
                                    const diff = Math.min(
                                        Math.abs(slotAng - ang),
                                        Math.PI * 2 - Math.abs(slotAng - ang)
                                    );
                                    if (diff < bestDiff) {
                                        bestDiff = diff;
                                        bestSlot = sIdx;
                                    }
                                });
                                if (bestSlot >= 0) {
                                    used.add(bestSlot);
                                    slotRelMap.set(bestSlot, rid);
                                }
                            });

                            // è®¡ç®—ç´§è´´åŠå¾„ï¼ˆä»…ä¿è¯æ¤­åœ†ä¸é‡å ï¼Œè¶Šè¿‘è¶Šå¥½ï¼‰
                            const entityR = getRadius(entityNode);
                            const attrR = attrs.length ? Math.max(...attrs.map(a => getRadius(a))) : 30;
                            const gap = 6;
                            const minRadEntity = entityR + attrR + gap;
                            let attrRadius = minRadEntity;
                            if (connectors > 1) {
                                const chordNeed = (attrR * 2 + gap);
                                const denom = Math.sin(angleStep / 2);
                                if (denom > 0.001) {
                                    attrRadius = Math.max(minRadEntity, chordNeed / (2 * denom));
                                }
                            }

                            // æŠŠå‰©ä½™æ§½ä½ç”¨äºå±æ€§ï¼Œæ”¾åœ¨æœ€é è¿‘çŸ©å½¢çš„åŠå¾„
                            const availableSlots = slots
                                .map((ang, idx) => ({ ang, idx }))
                                .filter(s => !used.has(s.idx))
                                .sort((a, b) => a.idx - b.idx);

                            attrs.forEach((attrNode, aIdx) => {
                                const slot = availableSlots[aIdx % availableSlots.length];
                                const angle = slot.ang;
                                const pos = {
                                    x: centerPos.x + Math.cos(angle) * attrRadius,
                                    y: centerPos.y + Math.sin(angle) * attrRadius
                                };
                                localTargets.set(attrNode.getModel().id, pos);
                            });
                        });

                        // è®¡ç®—ç»„ä»¶è¾¹ç•Œ
                        let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
                        localTargets.forEach((pos, id) => {
                            const node = nodeMap.get(id);
                            if (!node) return;
                            const r = getRadius(node);
                            minX = Math.min(minX, pos.x - r);
                            maxX = Math.max(maxX, pos.x + r);
                            minY = Math.min(minY, pos.y - r);
                            maxY = Math.max(maxY, pos.y + r);
                        });

                        return { targets: localTargets, bounds: { minX, maxX, minY, maxY } };
                    };

                    const componentLayouts = components.map(layoutComponent);

                    // å°†ç»„ä»¶å¹³é“ºåˆ°ç”»å¸ƒä¸Šï¼Œé¿å…äº’ç›¸é‡å 
                    const globalTargets = new Map();
                    let cursorX = componentGap;
                    let cursorY = componentGap;
                    let rowHeight = 0;
                    componentLayouts.forEach(layout => {
                        const { minX, maxX, minY, maxY } = layout.bounds;
                        const width = (maxX - minX) + componentGap;
                        const height = (maxY - minY) + componentGap;

                        if (cursorX + width > canvasWidth - componentGap) {
                            cursorX = componentGap;
                            cursorY += rowHeight + componentGap;
                            rowHeight = 0;
                        }

                        const offsetX = cursorX - minX;
                        const offsetY = cursorY - minY;

                        layout.targets.forEach((pos, id) => {
                            globalTargets.set(id, { x: pos.x + offsetX, y: pos.y + offsetY });
                        });

                        cursorX += width;
                        rowHeight = Math.max(rowHeight, height);
                    });

                    animateNodesToTargets(graph, globalTargets, 750, () => {
                        graph.refreshPositions();
                        setTimeout(() => smoothFitView(graph, 600, 'easeOutCubic'), 120);
                    });
                };

                // ç¯ç»•æ’å¸ƒï¼šè®©å±æ€§å‡åŒ€å›´ç»•å®ä½“ï¼ŒåŒæ—¶å¯ç§»åŠ¨å®ä½“ä»¥æ»¡è¶³å…³ç³»è·ç¦»
                const handleArrangeLayout = () => {
                    if (!graphRef.current || graphRef.current.destroyed) return;
                    const graph = graphRef.current;

                    const nodes = graph.getNodes();
                    if (!nodes.length) return;

                    const targets = new Map();
                    const nodeMap = new Map();
                    nodes.forEach(n => nodeMap.set(n.getModel().id, n));
                    const relAnchors = new Map();
                    const relRadii = new Map();

                    const entityNodes = nodes.filter(n => n.getModel().nodeType === 'entity');
                    const attributeNodes = nodes.filter(n => n.getModel().nodeType === 'attribute');
                    const relationshipNodes = nodes.filter(n => n.getModel().nodeType === 'relationship');

                    const getRadius = (node) => {
                        const bbox = node.getBBox();
                        // ä½¿ç”¨å¯¹è§’çº¿çš„ä¸€åŠä½œä¸ºåŠå¾„ï¼Œç¡®ä¿æ—‹è½¬æ—¶ä¹Ÿä¸ä¼šé‡å 
                        // è¿™æ ·å¯ä»¥æ›´å¥½åœ°å¤„ç†é•¿æ–¹å½¢å…ƒç´ 
                        return Math.sqrt(bbox.width * bbox.width + bbox.height * bbox.height) / 2;
                    };

                    const normalizeAngle = (a) => {
                        let angle = a % (Math.PI * 2);
                        if (angle < 0) angle += Math.PI * 2;
                        return angle;
                    };

                    // å»ºç«‹å…³ç³»èŠ‚ç‚¹ä¸å®ä½“èŠ‚ç‚¹çš„å¯¹åº”
                    const relationshipConnections = new Map(); // relId -> Set<entityNode>
                    graph.getEdges().forEach(edge => {
                        const { source, target } = edge.getModel();
                        const sourceNode = nodeMap.get(source);
                        const targetNode = nodeMap.get(target);
                        if (!sourceNode || !targetNode) return;
                        const sType = sourceNode.getModel().nodeType;
                        const tType = targetNode.getModel().nodeType;
                        if (sType === 'relationship' && tType === 'entity') {
                            if (!relationshipConnections.has(source)) relationshipConnections.set(source, new Set());
                            relationshipConnections.get(source).add(targetNode);
                        } else if (tType === 'relationship' && sType === 'entity') {
                            if (!relationshipConnections.has(target)) relationshipConnections.set(target, new Set());
                            relationshipConnections.get(target).add(sourceNode);
                        }
                    });

                    // æŒ‰å®ä½“æ”¶é›†å±æ€§ä¸å…³ç³»
                    const entityInfo = new Map(); // entityId -> {node, attrs:[], rels:[], satellites:[]}
                    entityNodes.forEach(e => entityInfo.set(e.getModel().id, { node: e, attrs: [], rels: [], satellites: [] }));
                    attributeNodes.forEach(a => {
                        const pid = a.getModel().parentEntity;
                        const info = entityInfo.get(pid);
                        if (info) {
                            info.attrs.push(a);
                            info.satellites.push({ node: a, type: 'attr' }); // ç»Ÿä¸€ç®¡ç†å«æ˜ŸèŠ‚ç‚¹
                        }
                    });
                    relationshipNodes.forEach(r => {
                        const set = relationshipConnections.get(r.getModel().id);
                        if (set) {
                            const connected = Array.from(set);
                            connected.forEach(entityNode => {
                                const info = entityInfo.get(entityNode.getModel().id);
                                if (!info) return;
                                // æ‰¾åˆ°å¦ä¸€ç«¯å®ä½“
                                const other = connected.find(n => n !== entityNode) || null;
                                info.rels.push({ relNode: r, otherEntity: other });
                                info.satellites.push({ node: r, type: 'rel', otherEntity: other }); // ç»Ÿä¸€ç®¡ç†å«æ˜ŸèŠ‚ç‚¹
                            });
                        }
                    });

                    // å½“å‰å®ä½“åæ ‡ï¼Œå¯è¢«è¿­ä»£çŸ«æ­£
                    const entityPositions = new Map();
                    entityNodes.forEach(n => {
                        const m = n.getModel();
                        entityPositions.set(m.id, { x: m.x, y: m.y });
                    });

                    // è®¡ç®—æ¯ä¸ªå®ä½“çš„ç»Ÿä¸€ç¯ç»•åŠå¾„ï¼ˆæ‰€æœ‰å«æ˜ŸèŠ‚ç‚¹ä½¿ç”¨ç›¸åŒåŠå¾„ï¼‰
                    const baseRing = new Map(); // ç»Ÿä¸€çš„ç¯ç»•åŠå¾„ï¼ˆä¸­å¿ƒåˆ°å«æ˜Ÿä¸­å¿ƒï¼‰
                    const systemRadius = new Map(); // å®ä½“çš„ç¢°æ’åŠå¾„ï¼ˆä¸­å¿ƒåˆ°å«æ˜Ÿå¤–æ²¿ï¼‰

                    entityInfo.forEach(info => {
                        const entityRadius = getRadius(info.node);

                        // è·å–æ‰€æœ‰å«æ˜ŸèŠ‚ç‚¹ï¼ˆå±æ€§+å…³ç³»ï¼‰çš„æœ€å¤§åŠå¾„
                        const maxSatelliteRadius = info.satellites.length > 0
                            ? Math.max(...info.satellites.map(s => getRadius(s.node)))
                            : 30;

                        // åŸºç¡€ç¯åŠå¾„ï¼šå®ä½“åŠå¾„ + æœ€å¤§å«æ˜ŸåŠå¾„ + é—´éš™
                        let ringR = entityRadius + maxSatelliteRadius + 25;

                        // æ£€æŸ¥å‘¨é•¿éœ€æ±‚ï¼šç¡®ä¿æ‰€æœ‰å«æ˜ŸèŠ‚ç‚¹èƒ½å‡åŒ€åˆ†å¸ƒä¸”ä¸é‡å 
                        if (info.satellites.length > 1) {
                            const count = info.satellites.length;
                            // æ¯ä¸ªå«æ˜ŸèŠ‚ç‚¹éœ€è¦çš„å¼§é•¿ = ç›´å¾„ + é—´éš™
                            const requiredArcLength = maxSatelliteRadius * 2 + 18;
                            const totalCircumference = count * requiredArcLength;
                            const requiredRingR = totalCircumference / (2 * Math.PI);
                            ringR = Math.max(ringR, requiredRingR);
                        }

                        baseRing.set(info.node.getModel().id, ringR);
                        // ç³»ç»ŸåŠå¾„ = ç¯åŠå¾„ + æœ€å¤§å«æ˜ŸåŠå¾„ (è¿™æ˜¯å®ä½“çš„æœ€å¤–å±‚è¾¹ç•Œ)
                        systemRadius.set(info.node.getModel().id, ringR + maxSatelliteRadius);
                    });

                    // å¼¹ç°§è¿­ä»£ + ç¢°æ’æ£€æµ‹
                    const safeGap = 50; // å®ä½“ç³»ç»Ÿä¹‹é—´çš„å®‰å…¨é—´è·
                    const entityIds = Array.from(entityPositions.keys());

                    for (let iter = 0; iter < 300; iter++) {
                        let maxMove = 0;

                        // 1. å¸å¼•åŠ›ï¼šé€šè¿‡å…³ç³»è¿æ¥çš„å®ä½“
                        relationshipNodes.forEach(relNode => {
                            const relId = relNode.getModel().id;
                            const connected = relationshipConnections.get(relId);
                            if (!connected || connected.size !== 2) return;
                            const [entityA, entityB] = Array.from(connected.values());
                            const idA = entityA.getModel().id;
                            const idB = entityB.getModel().id;
                            const posA = entityPositions.get(idA);
                            const posB = entityPositions.get(idB);
                            if (!posA || !posB) return;

                            const dx = posB.x - posA.x;
                            const dy = posB.y - posA.y;
                            const dist = Math.hypot(dx, dy) || 1;

                            // æœŸæœ›è·ç¦» = ä¸¤ä¸ªå®ä½“çš„ç³»ç»ŸåŠå¾„ä¹‹å’Œ + é—´éš™
                            const rA = systemRadius.get(idA);
                            const rB = systemRadius.get(idB);
                            const desired = rA + rB + safeGap;

                            const diff = desired - dist;
                            if (Math.abs(diff) < 1) return;

                            const nx = dx / dist;
                            const ny = dy / dist;
                            // ç§»åŠ¨ç³»æ•°ï¼Œè·ç¦»è¶Šè¿œæ‹‰åŠ›è¶Šå¤§ï¼Œè·ç¦»è¶Šè¿‘æ–¥åŠ›è¶Šå¤§
                            const move = (diff * 0.2) / 2;

                            posA.x -= nx * move;
                            posA.y -= ny * move;
                            posB.x += nx * move;
                            posB.y += ny * move;
                            maxMove = Math.max(maxMove, Math.abs(move));
                        });

                        // 2. å…¨å±€æ–¥åŠ›ï¼šé˜²æ­¢ä»»æ„ä¸¤ä¸ªå®ä½“é‡å 
                        for (let i = 0; i < entityIds.length; i++) {
                            for (let j = i + 1; j < entityIds.length; j++) {
                                const idA = entityIds[i];
                                const idB = entityIds[j];
                                const posA = entityPositions.get(idA);
                                const posB = entityPositions.get(idB);

                                const dx = posB.x - posA.x;
                                const dy = posB.y - posA.y;
                                const dist = Math.hypot(dx, dy) || 1;

                                const rA = systemRadius.get(idA);
                                const rB = systemRadius.get(idB);
                                const minDesc = rA + rB + safeGap; // æœ€å°å…è®¸è·ç¦»

                                if (dist < minDesc) {
                                    // å‘ç”Ÿé‡å æˆ–è·ç¦»è¿‡è¿‘ï¼Œæ–½åŠ æ–¥åŠ›
                                    const overlap = minDesc - dist;
                                    const nx = dx / dist;
                                    const ny = dy / dist;
                                    const move = overlap * 0.5 * 0.5; // è¾ƒå¼ºçš„æ–¥åŠ›

                                    posA.x -= nx * move;
                                    posA.y -= ny * move;
                                    posB.x += nx * move;
                                    posB.y += ny * move;
                                    maxMove = Math.max(maxMove, move);
                                }
                            }
                        }

                        if (maxMove < 0.5) break;
                    }

                    // è°ƒæ•´å®ä½“é—´è·ï¼Œè®©å…³ç³»è±å½¢å¯ä»¥æ”¾åœ¨ä¸­ç‚¹ä¸”è¿çº¿ç­‰é•¿
                    const ensureRelationshipClearance = () => {
                        // é¢„ç•™ç»™å…³ç³»èŠ‚ç‚¹çš„æœ€å°åŠå¾„ä¸é—´éš™
                        const clearanceGap = 12;

                        relationshipNodes.forEach(relNode => {
                            const relId = relNode.getModel().id;
                            const connected = relationshipConnections.get(relId);
                            if (!connected || connected.size !== 2) return;

                            const [entityA, entityB] = Array.from(connected.values());
                            const idA = entityA.getModel().id;
                            const idB = entityB.getModel().id;
                            const posA = entityPositions.get(idA);
                            const posB = entityPositions.get(idB);
                            if (!posA || !posB) return;

                            const dx = posB.x - posA.x;
                            const dy = posB.y - posA.y;
                            const dist = Math.hypot(dx, dy) || 1;

                            const relRadius = getRadius(relNode);
                            // ä»¥ä¸¤ç«¯å±æ€§ç¯åŠå¾„ä¸ºåŸºå‡†ï¼Œä¿è¯è±å½¢ä½äºä¸¤å®ä½“å¤–åœˆä¹‹å¤–
                            const minHalf = Math.max(
                                (baseRing.get(idA) || 40) + relRadius + clearanceGap,
                                (baseRing.get(idB) || 40) + relRadius + clearanceGap
                            );

                            const requiredDist = minHalf * 2;
                            if (dist >= requiredDist) return;

                            const missing = requiredDist - dist;
                            const nx = dx / dist;
                            const ny = dy / dist;

                            // å¯¹ç§°åœ°æ¨å¼€ä¸¤ä¸ªå®ä½“
                            posA.x -= nx * missing / 2;
                            posA.y -= ny * missing / 2;
                            posB.x += nx * missing / 2;
                            posB.y += ny * missing / 2;
                        });
                    };

                    // è¿è¡Œä¸‰è½®ï¼Œä¼ æ’­æ¨å¼€æ•ˆæœ
                    ensureRelationshipClearance();
                    ensureRelationshipClearance();
                    ensureRelationshipClearance();

                    // å®ä½“ç›®æ ‡ä½ç½®
                    // å®ä½“ç›®æ ‡ä½ç½®
                    entityPositions.forEach((pos, id) => targets.set(id, { ...pos }));

                    const entityOrbitRadius = new Map();

                    // ç»Ÿä¸€å¸ƒå±€æ‰€æœ‰å«æ˜ŸèŠ‚ç‚¹(å±æ€§+å•å®ä½“å…³ç³»)
                    entityInfo.forEach(info => {
                        const { node, satellites } = info;
                        const model = node.getModel();
                        const center = entityPositions.get(model.id) || { x: model.x, y: model.y };

                        // ä½¿ç”¨é¢„è®¡ç®—çš„ç»Ÿä¸€ç¯ç»•åŠå¾„
                        const ringRadius = baseRing.get(model.id);
                        entityOrbitRadius.set(model.id, ringRadius);

                        if (!satellites.length) return;

                        // æ‰¾å‡ºéœ€è¦é¿å¼€çš„è§’åº¦(åŒå®ä½“å…³ç³»çš„æ–¹å‘)
                        const avoidAngles = [];
                        satellites.forEach(s => {
                            if (s.type === 'rel' && s.otherEntity) {
                                const otherPos = entityPositions.get(s.otherEntity.getModel().id);
                                if (otherPos) {
                                    const angle = normalizeAngle(Math.atan2(otherPos.y - center.y, otherPos.x - center.x));
                                    avoidAngles.push(angle);
                                }
                            }
                        });

                        // è®¡ç®—å¯ç”¨è§’åº¦åŒºé—´
                        const gapAngle = 0.35; // å…³ç³»æ–¹å‘ç•™ç™½è§’åº¦
                        const halfGap = gapAngle / 2;
                        let segments = [];

                        if (!avoidAngles.length) {
                            // æ²¡æœ‰éœ€è¦é¿å¼€çš„è§’åº¦,æ•´åœˆå¯ç”¨
                            segments.push({ start: 0, end: Math.PI * 2 });
                        } else {
                            // è®¡ç®—å„ä¸ªå¯ç”¨åŒºé—´
                            const sortedAngles = avoidAngles.slice().sort((a, b) => a - b);
                            const total = Math.PI * 2;
                            for (let i = 0; i < sortedAngles.length; i++) {
                                const curr = sortedAngles[i];
                                const next = sortedAngles[(i + 1) % sortedAngles.length] + (i === sortedAngles.length - 1 ? total : 0);
                                const start = curr + halfGap;
                                const end = next - halfGap;
                                if (end > start) segments.push({ start, end });
                            }
                        }

                        // æ£€æŸ¥æ€»å¯ç”¨è§’åº¦
                        const totalFree = segments.reduce((sum, s) => sum + (s.end - s.start), 0);
                        if (totalFree <= 0) {
                            // é—´éš™è¢«å æ»¡,é€€åŒ–ä¸ºæ•´åœˆ
                            segments = [{ start: 0, end: Math.PI * 2 }];
                        }

                        // æ”¶é›†éœ€è¦åœ¨ç¯ä¸Šå¸ƒå±€çš„å«æ˜ŸèŠ‚ç‚¹(æ’é™¤åŒå®ä½“å…³ç³»)
                        const orbitalSatellites = satellites.filter(s =>
                            s.type === 'attr' || (s.type === 'rel' && !s.otherEntity)
                        );

                        if (!orbitalSatellites.length) return;

                        // æŒ‰å½“å‰è§’åº¦æ’åº,å‡å°‘ä½ç§»
                        const sortedSatellites = orbitalSatellites.slice().sort((a, b) => {
                            const ma = a.node.getModel();
                            const mb = b.node.getModel();
                            const angleA = normalizeAngle(Math.atan2(ma.y - center.y, ma.x - center.x));
                            const angleB = normalizeAngle(Math.atan2(mb.y - center.y, mb.x - center.x));
                            return angleA - angleB;
                        });

                        // åœ¨æ‰€æœ‰å¯ç”¨åŒºé—´å†…å‡åŒ€åˆ†é…å«æ˜ŸèŠ‚ç‚¹
                        const totalCount = sortedSatellites.length;
                        const totalAngle = segments.reduce((sum, s) => sum + (s.end - s.start), 0);

                        // è®¡ç®—æ¯ä¸ªåŒºé—´åº”åˆ†é…çš„èŠ‚ç‚¹æ•°
                        const segCounts = segments.map(s =>
                            Math.max(0, Math.round(totalCount * (s.end - s.start) / totalAngle))
                        );

                        // è°ƒæ•´åˆ†é…æ•°é‡,ç¡®ä¿æ€»å’Œæ­£ç¡®
                        let allocated = segCounts.reduce((sum, c) => sum + c, 0);
                        let segIdx = 0;
                        while (allocated < totalCount) {
                            // æ‰¾æœ€å¤§çš„åŒºé—´å¢åŠ ä¸€ä¸ª
                            let maxIdx = 0;
                            let maxLen = -Infinity;
                            segments.forEach((s, idx) => {
                                if (s.end - s.start > maxLen) {
                                    maxLen = s.end - s.start;
                                    maxIdx = idx;
                                }
                            });
                            segCounts[maxIdx]++;
                            allocated++;
                        }
                        while (allocated > totalCount) {
                            // æ‰¾æœ‰åˆ†é…çš„åŒºé—´å‡å°‘ä¸€ä¸ª
                            for (let i = segCounts.length - 1; i >= 0; i--) {
                                if (segCounts[i] > 0) {
                                    segCounts[i]--;
                                    allocated--;
                                    break;
                                }
                            }
                        }

                        // åœ¨æ¯ä¸ªåŒºé—´å†…å‡åŒ€æ”¾ç½®èŠ‚ç‚¹
                        let nodeIdx = 0;
                        segments.forEach((s, idx) => {
                            const count = segCounts[idx];
                            if (!count) return;

                            // è®¡ç®—è¯¥åŒºé—´å†…çš„è§’åº¦æ­¥é•¿
                            const step = (s.end - s.start) / count;

                            for (let i = 0; i < count; i++) {
                                // å‡åŒ€åˆ†å¸ƒ:ä»åŒºé—´èµ·ç‚¹+åŠæ­¥é•¿å¼€å§‹
                                const angle = s.start + step * (i + 0.5);
                                const useAngle = normalizeAngle(angle);

                                const targetX = center.x + ringRadius * Math.cos(useAngle);
                                const targetY = center.y + ringRadius * Math.sin(useAngle);

                                const satellite = sortedSatellites[nodeIdx++];
                                if (satellite) {
                                    targets.set(satellite.node.getModel().id, { x: targetX, y: targetY });
                                }
                            }
                        });
                    });

                    // åŒå®ä½“å…³ç³»èŠ‚ç‚¹ï¼šæ²¿å®ä½“è¿çº¿åˆ†å¸ƒ,ç¡®ä¿åˆ°ä¸¤ç«¯çš„è·ç¦»ç›¸ç­‰
                    relationshipNodes.forEach(relNode => {
                        const relId = relNode.getModel().id;
                        const connectedEntities = relationshipConnections.get(relId);

                        if (connectedEntities && connectedEntities.size === 2) {
                            const [entityA, entityB] = Array.from(connectedEntities.values());
                            const idA = entityA.getModel().id;
                            const idB = entityB.getModel().id;
                            const posA = entityPositions.get(idA);
                            const posB = entityPositions.get(idB);
                            if (!posA || !posB) return;

                            const dx = posB.x - posA.x;
                            const dy = posB.y - posA.y;
                            const dist = Math.hypot(dx, dy) || 1;

                            // å°†å…³ç³»èŠ‚ç‚¹æ”¾åœ¨ä¸¤å®ä½“çš„å‡ ä½•ä¸­å¿ƒ,ä½¿è¿çº¿é•¿åº¦ç›¸ç­‰
                            const midX = (posA.x + posB.x) / 2;
                            const midY = (posA.y + posB.y) / 2;

                            const anchorPos = { x: midX, y: midY };
                            targets.set(relId, anchorPos);
                            relAnchors.set(relId, anchorPos);
                            relRadii.set(relId, getRadius(relNode));
                        }
                        // æ³¨æ„:å•å®ä½“å…³ç³»å·²åœ¨ä¸Šé¢çš„ç»Ÿä¸€å«æ˜Ÿå¸ƒå±€ä¸­å¤„ç†
                    });

                    // åŒä¸€å®ä½“å¯¹ä¹‹é—´çš„å¤šä¸ªå…³ç³»è±å½¢åˆ†å¸ƒåˆ°å‚ç›´æ–¹å‘ï¼Œé¿å…é‡å 
                    const groupedRelations = new Map(); // key: sortedEntityIdA-IdB => [{relNode, relRadius, entities}]
                    relationshipNodes.forEach(relNode => {
                        const relId = relNode.getModel().id;
                        const connected = relationshipConnections.get(relId);
                        if (!connected || connected.size !== 2) return;
                        const [entityA, entityB] = Array.from(connected.values());
                        const idA = entityA.getModel().id;
                        const idB = entityB.getModel().id;
                        const key = idA < idB ? `${idA}__${idB}` : `${idB}__${idA}`;
                        if (!groupedRelations.has(key)) groupedRelations.set(key, []);
                        groupedRelations.get(key).push({
                            relNode,
                            relRadius: getRadius(relNode),
                            entities: [entityA, entityB]
                        });
                    });

                    groupedRelations.forEach(list => {
                        if (list.length <= 1) return;
                        // åŸºäºä¸­å¿ƒç‚¹è¿›è¡Œå‚ç›´åç§»
                        const sample = list[0];
                        const [entityA, entityB] = sample.entities;
                        const idA = entityA.getModel().id;
                        const idB = entityB.getModel().id;
                        const posA = entityPositions.get(idA);
                        const posB = entityPositions.get(idB);
                        if (!posA || !posB) return;
                        const dx = posB.x - posA.x;
                        const dy = posB.y - posA.y;
                        const dist = Math.hypot(dx, dy) || 1;
                        const nx = dx / dist;
                        const ny = dy / dist;
                        // å‚ç›´æ–¹å‘å•ä½å‘é‡
                        const px = -ny;
                        const py = nx;

                        const baseX = targets.get(sample.relNode.getModel().id)?.x || (posA.x + posB.x) / 2;
                        const baseY = targets.get(sample.relNode.getModel().id)?.y || (posA.y + posB.y) / 2;
                        const maxRadius = Math.max(...list.map(item => item.relRadius));
                        const offsetStep = maxRadius * 2 + 16;

                        // ä»¥ä¸­å¿ƒä¸ºå¯¹ç§°ç‚¹åˆ†å¸ƒ
                        const sorted = list.slice().sort((a, b) => a.relNode.getModel().id.localeCompare(b.relNode.getModel().id));
                        const mid = (sorted.length - 1) / 2;
                        sorted.forEach((item, idx) => {
                            const offsetIndex = idx - mid;
                            const ox = px * offsetIndex * offsetStep;
                            const oy = py * offsetIndex * offsetStep;
                            const newPos = { x: baseX + ox, y: baseY + oy };
                            const rid = item.relNode.getModel().id;
                            targets.set(rid, newPos);
                            relAnchors.set(rid, newPos);
                        });
                    });

                    // å…³ç³»èŠ‚ç‚¹é¢å¤–é˜²é‡å ä¿®æ­£ï¼šå¯¹å…³ç³»èŠ‚ç‚¹é—´ã€å…³ç³»èŠ‚ç‚¹ä¸å®ä½“åšè½»é‡æ–¥åŠ›ï¼Œä¿æŒé”šç‚¹é™„è¿‘
                    if (relAnchors.size) {
                        const relPositions = new Map();
                        relAnchors.forEach((anchor, id) => {
                            const t = targets.get(id);
                            relPositions.set(id, t ? { ...t } : { ...anchor });
                        });

                        const entityCollisionRadius = new Map();
                        entityNodes.forEach(en => {
                            const mid = en.getModel();
                            const ring = entityOrbitRadius.get(mid.id) || baseRing.get(mid.id) || 60;
                            // è®©å…³ç³»èŠ‚ç‚¹è¿œç¦»å®ä½“å¤–åœˆ
                            entityCollisionRadius.set(mid.id, ring + 20);
                        });

                        for (let iter = 0; iter < 80; iter++) {
                            // å…³ç³»èŠ‚ç‚¹é—´æ–¥åŠ›
                            relationshipNodes.forEach((relA, idxA) => {
                                const idA = relA.getModel().id;
                                const posA = relPositions.get(idA);
                                const rA = relRadii.get(idA) || 30;
                                if (!posA) return;

                                for (let j = idxA + 1; j < relationshipNodes.length; j++) {
                                    const relB = relationshipNodes[j];
                                    const idB = relB.getModel().id;
                                    const posB = relPositions.get(idB);
                                    const rB = relRadii.get(idB) || 30;
                                    if (!posB) continue;

                                    const dx = posB.x - posA.x;
                                    const dy = posB.y - posA.y;
                                    let dist = Math.hypot(dx, dy);
                                    if (dist === 0) dist = 0.01;
                                    const minDist = rA + rB + 14;
                                    if (dist < minDist) {
                                        const push = (minDist - dist) / 2;
                                        const nx = dx / dist;
                                        const ny = dy / dist;
                                        posA.x -= nx * push;
                                        posA.y -= ny * push;
                                        posB.x += nx * push;
                                        posB.y += ny * push;
                                    }
                                }
                            });

                            // å…³ç³»èŠ‚ç‚¹é¿å¼€å®ä½“å¤–åœˆ
                            relPositions.forEach((pos, rid) => {
                                // æ‰¾åˆ°å…³è”çš„å®ä½“
                                const relNode = graph.findById(rid);
                                const connected = relNode ? relationshipConnections.get(rid) : null;
                                if (!connected) return;

                                connected.forEach(entNode => {
                                    const em = entNode.getModel();
                                    const center = entityPositions.get(em.id) || { x: em.x, y: em.y };
                                    const limit = entityCollisionRadius.get(em.id) || 80;
                                    const dx = pos.x - center.x;
                                    const dy = pos.y - center.y;
                                    let dist = Math.hypot(dx, dy);
                                    if (dist === 0) dist = 0.01;
                                    if (dist < limit) {
                                        const push = (limit - dist);
                                        const nx = dx / dist;
                                        const ny = dy / dist;
                                        pos.x += nx * push;
                                        pos.y += ny * push;
                                    }
                                });
                            });

                            // è½»å¾®æ‹‰å›é”šç‚¹ï¼Œé˜²æ­¢æ¼‚ç§»è¿‡è¿œ
                            relPositions.forEach((pos, id) => {
                                const anchor = relAnchors.get(id);
                                if (!anchor) return;
                                pos.x = pos.x * 0.85 + anchor.x * 0.15;
                                pos.y = pos.y * 0.85 + anchor.y * 0.15;
                            });
                        }

                        // åº”ç”¨ä¿®æ­£åçš„å…³ç³»ä½ç½®
                        relPositions.forEach((pos, id) => {
                            targets.set(id, { ...pos });
                        });
                    }

                    // å…¨å±€é˜²é‡å ï¼ˆæ‰€æœ‰å½¢çŠ¶ï¼‰
                    const applyGlobalSeparation = () => {
                        const allNodes = graph.getNodes();
                        const meta = allNodes.map(n => ({
                            id: n.getModel().id,
                            r: getRadius(n)
                        }));
                        // ç¡®ä¿æ¯ä¸ªèŠ‚ç‚¹éƒ½æœ‰ç›®æ ‡
                        meta.forEach(m => {
                            if (!targets.has(m.id)) {
                                const model = graph.findById(m.id)?.getModel();
                                targets.set(m.id, { x: model?.x || 0, y: model?.y || 0 });
                            }
                        });

                        for (let iter = 0; iter < 400; iter++) {
                            let maxMove = 0;
                            for (let i = 0; i < meta.length; i++) {
                                for (let j = i + 1; j < meta.length; j++) {
                                    const a = meta[i], b = meta[j];
                                    const pa = targets.get(a.id);
                                    const pb = targets.get(b.id);
                                    if (!pa || !pb) continue;
                                    const dx = pb.x - pa.x;
                                    const dy = pb.y - pa.y;
                                    let dist = Math.hypot(dx, dy);
                                    if (dist === 0) dist = 0.01;
                                    const minDist = a.r + b.r + 8;
                                    if (dist < minDist) {
                                        const push = (minDist - dist) / 2;
                                        const nx = dx / dist;
                                        const ny = dy / dist;
                                        pa.x -= nx * push;
                                        pa.y -= ny * push;
                                        pb.x += nx * push;
                                        pb.y += ny * push;
                                        maxMove = Math.max(maxMove, push);
                                    }
                                }
                            }
                            if (maxMove < 0.3) break;
                        }
                    };

                    applyGlobalSeparation();

                    animateNodesToTargets(graph, targets, 850, () => {
                        smoothFitView(graph, 800, 'easeOutCubic');
                    });
                };

                return (
                    <div className="main-content">
                        <div className="input-section">
                            <div className="card">
                                <div className="card-header">
                                    <h2 className="card-title">
                                        <span style={{ fontSize: '1.5rem' }}>ğŸ“„</span>
                                        SQL / DBML è¾“å…¥
                                    </h2>
                                </div>
                                <div className="card-content">
                                    <div style={{ height: '480px', display: 'flex', flexDirection: 'column' }}>
                                        <CodeEditor
                                            value={inputText}
                                            onChange={setInputText}
                                            placeholder="åœ¨æ­¤å¤„ç²˜è´´æ‚¨çš„ CREATE TABLE æˆ– DBML è¯­å¥..."
                                        />
                                    </div>
                                    <div className="button-group">
                                        <button
                                            className="btn btn-primary"
                                            onClick={handleGenerate}
                                            disabled={loading}
                                        >
                                            {loading ? <div className="spinner" style={{ width: 20, height: 20, borderWidth: 2 }}></div> : 'âš¡ ç”ŸæˆERå›¾'}
                                        </button>
                                        <button
                                            className="btn btn-secondary"
                                            onClick={handleExportSVG}
                                            disabled={!hasGraph}
                                        >
                                            ğŸ“¥ å¯¼å‡ºSVG
                                        </button>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <div className="output-section">
                            <div className="card">
                                <div className="card-header" style={{ flexWrap: 'wrap', gap: '16px', height: 'auto' }}>
                                    <div style={{ display: 'flex', alignItems: 'center', gap: '24px', flex: 1, minWidth: '300px' }}>
                                        <h2 className="card-title" style={{ whiteSpace: 'nowrap' }}>
                                            <span style={{ fontSize: '1.5rem' }}>ğŸ¨</span>
                                            ERå›¾é¢„è§ˆ
                                        </h2>

                                        <div style={{ display: 'flex', gap: '8px', alignItems: 'center', flexWrap: 'wrap' }}>
                                            <div className="legend-item" style={{ padding: '4px 10px', fontSize: '0.8rem' }}>
                                                <div style={{ width: '10px', height: '10px', borderRadius: '3px', background: isColored ? '#e0f2fe' : '#fff', border: isColored ? '2px solid #0ea5e9' : '2px solid #1e293b' }}></div>
                                                <span>å®ä½“</span>
                                            </div>
                                            <div className="legend-item" style={{ padding: '4px 10px', fontSize: '0.8rem' }}>
                                                <div style={{ width: '10px', height: '10px', transform: 'rotate(45deg)', background: isColored ? '#f5f3ff' : '#fff', border: isColored ? '2px solid #8b5cf6' : '2px solid #1e293b' }}></div>
                                                <span style={{ marginLeft: '4px' }}>å…³ç³»</span>
                                            </div>
                                            <div className="legend-item" style={{ padding: '4px 10px', fontSize: '0.8rem' }}>
                                                <div style={{ width: '10px', height: '10px', borderRadius: '50%', background: isColored ? '#fff' : '#fff', border: isColored ? '2px solid #94a3b8' : '1px solid #1e293b' }}></div>
                                                <span>å±æ€§</span>
                                            </div>
                                            <div className="legend-item" style={{ padding: '4px 10px', fontSize: '0.8rem' }}>
                                                <div style={{ width: '10px', height: '10px', borderRadius: '50%', background: isColored ? '#ecfdf5' : '#fff', border: isColored ? '2px solid #10b981' : '2px solid #1e293b' }}></div>
                                                <span style={{ fontWeight: 600, color: isColored ? '#059669' : 'inherit' }}>ä¸»é”®</span>
                                            </div>
                                        </div>
                                    </div>

                                    <div style={{ display: 'flex', alignItems: 'center', gap: '16px', marginLeft: 'auto' }}>
                                        <button
                                            className="btn btn-sm btn-accent"
                                            onClick={handleArrangeLayout}
                                            disabled={!hasGraph || loading}
                                        >
                                            âœ¨ æ™ºèƒ½å¸ƒå±€
                                        </button>
                                        <button
                                            className="btn btn-sm btn-accent"
                                            onClick={handleForceAlign}
                                            disabled={!hasGraph || loading}
                                        >
                                            ğŸ“ å¼ºåˆ¶å¯¹é½
                                        </button>
                                    </div>
                                </div>

                                <div className="card-content" style={{ position: 'relative', padding: 0, display: 'flex', flexDirection: 'column', height: '100%' }}>
                                    {error && (
                                        <div className="error-message" style={{ margin: '20px' }}>
                                            âš ï¸ {error}
                                        </div>
                                    )}

                                    <div className={`diagram-container ${showBackground ? '' : 'no-grid'}`} style={{ border: 'none', borderRadius: 0 }}>
                                        <div
                                            className="background-toggle"
                                            onClick={handleToggleBackground}
                                            title={showBackground ? 'éšè—èƒŒæ™¯' : 'æ˜¾ç¤ºèƒŒæ™¯'}
                                        >
                                            <i className={`fa-solid ${showBackground ? 'fa-eye' : 'fa-eye-slash'}`}></i>
                                        </div>
                                        <div
                                            className={`colorize-toggle ${isColored ? 'active' : ''}`}
                                            onClick={() => setIsColored(!isColored)}
                                            title={isColored ? 'å…³é—­ç€è‰²' : 'å¼€å¯ç€è‰²'}
                                        >
                                            <i className="fa-solid fa-palette"></i>
                                        </div>
                                        {loading && (
                                            <div className="loading-overlay">
                                                <div className="spinner"></div>
                                            </div>
                                        )}
                                        <div
                                            ref={containerRef}
                                            style={{
                                                width: '100%',
                                                height: '100%',
                                                position: 'relative'
                                            }}
                                        />
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                );
            };

            const root = ReactDOM.createRoot(document.getElementById('root'));
            root.render(
                <React.StrictMode>
                    <App />
                </React.StrictMode>
            );
        });
    </script>
</body>

</html>