<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SQL/DBML2ER</title>
    <link rel="stylesheet" href="https://unpkg.com/antd@5.19.1/dist/reset.css" />
    <link rel="stylesheet" href="https://unpkg.com/antd@5.19.1/dist/antd.min.css" />
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/codemirror.min.css" />
    <style>
        :root {
            --primary: #0f172a;
            --primary-light: #334155;
            --secondary: #64748b;
            --accent: #0ea5e9;
            /* Sky 500 */
            --accent-hover: #0284c7;
            --accent-gradient: linear-gradient(135deg, #0ea5e9 0%, #2563eb 100%);
            --success: #10b981;
            --bg-page: #f8fafc;
            --bg-card: rgba(255, 255, 255, 0.7);
            --border: rgba(226, 232, 240, 0.8);
            --glass-border: 1px solid rgba(255, 255, 255, 0.6);
            --glass-shadow: 0 10px 40px -10px rgba(0, 0, 0, 0.05);
            --text-main: #1e293b;
            --text-sub: #64748b;
            --radius-lg: 24px;
            --radius-md: 16px;
            --radius-sm: 12px;
            --font-sans: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            --font-mono: 'JetBrains Mono', 'SF Mono', Consolas, monospace;
        }

        * {
            box-sizing: border-box;
            outline: none;
        }

        body {
            background-color: var(--bg-page);
            background-image:
                radial-gradient(circle at 0% 0%, rgba(14, 165, 233, 0.08) 0%, transparent 50%),
                radial-gradient(circle at 100% 100%, rgba(99, 102, 241, 0.08) 0%, transparent 50%);
            background-attachment: fixed;
            color: var(--text-main);
            font-family: var(--font-sans);
            min-height: 100vh;
            margin: 0;
            padding: 0;
            line-height: 1.6;
            -webkit-font-smoothing: antialiased;
        }

        .app-container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 40px 32px;
        }

        .header {
            text-align: center;
            margin-bottom: 60px;
            animation: fadeInDown 1s cubic-bezier(0.16, 1, 0.3, 1);
        }

        .header h1 {
            font-size: 3.5rem;
            font-weight: 800;
            background: linear-gradient(135deg, #0f172a 0%, #334155 100%);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            margin: 0 0 16px 0;
            letter-spacing: -0.03em;
            line-height: 1.1;
        }

        .header p {
            font-size: 1.25rem;
            color: var(--text-sub);
            margin: 0;
            font-weight: 400;
            opacity: 0.8;
        }

        .main-content {
            display: grid;
            grid-template-columns: 420px 1fr;
            gap: 32px;
            align-items: stretch;
            animation: fadeInUp 1s cubic-bezier(0.16, 1, 0.3, 1) 0.2s backwards;
        }

        .card {
            background: var(--bg-card);
            -webkit-backdrop-filter: blur(20px);
            backdrop-filter: blur(20px);
            border-radius: var(--radius-lg);
            box-shadow: var(--glass-shadow);
            border: var(--glass-border);
            overflow: hidden;
            display: flex;
            flex-direction: column;
            height: 100%;
        }

        .card-header {
            padding: 24px 32px;
            border-bottom: 1px solid rgba(226, 232, 240, 0.6);
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: rgba(255, 255, 255, 0.4);
        }

        .card-title {
            font-size: 1.2rem;
            font-weight: 700;
            color: var(--primary);
            margin: 0;
            display: flex;
            align-items: center;
            gap: 10px;
            letter-spacing: -0.01em;
        }

        .card-content {
            padding: 32px;
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 24px;
        }

        .input-textarea {
            width: 100%;
            min-height: 480px;
            border: 1px solid transparent;
            border-radius: var(--radius-md);
            padding: 20px;
            font-family: var(--font-mono);
            font-size: 14px;
            line-height: 1.6;
            background: #fff;
            color: var(--text-main);
            resize: none;
            transition: all 0.3s ease;
            flex: 1;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.02);
        }

        .input-textarea:focus {
            outline: none;
            background: #fff;
            box-shadow: 0 0 0 4px rgba(14, 165, 233, 0.1), inset 0 2px 4px rgba(0, 0, 0, 0.02);
        }

        .btn {
            height: 48px;
            border: none;
            border-radius: 9999px;
            font-size: 15px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.16, 1, 0.3, 1);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            width: 100%;
            letter-spacing: 0.01em;
        }

        .btn-primary {
            background: var(--accent-gradient);
            color: white;
            box-shadow: 0 4px 12px rgba(14, 165, 233, 0.3);
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(14, 165, 233, 0.4);
        }

        .btn-primary:active {
            transform: translateY(0);
        }

        .btn-primary:disabled {
            opacity: 0.7;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .btn-secondary {
            background: white;
            color: var(--text-main);
            border: 1px solid var(--border);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.02);
        }

        .btn-secondary:hover {
            background: #f8fafc;
            border-color: #cbd5e1;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
        }

        .btn-sm {
            height: 36px;
            padding: 0 20px;
            font-size: 13px;
            border-radius: 9999px;
            width: auto;
        }

        .btn-accent {
            background: rgba(14, 165, 233, 0.1);
            color: var(--accent);
            border: 1px solid rgba(14, 165, 233, 0.2);
        }

        .btn-accent:hover {
            background: rgba(14, 165, 233, 0.15);
            transform: translateY(-1px);
        }

        .diagram-container {
            width: 100%;
            flex: 1;
            min-height: 600px;
            background-color: #ffffff;
            background-image: radial-gradient(#cbd5e1 1.5px, transparent 1.5px);
            background-size: 24px 24px;
            border-radius: var(--radius-md);
            position: relative;
            overflow: hidden;
            border: 1px solid rgba(226, 232, 240, 0.6);
            box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.01);
            transition: background-image 0.3s ease;
        }

        .diagram-container.no-grid {
            background-image: none;
        }

        .background-toggle {
            position: absolute;
            top: 16px;
            left: 16px;
            width: 40px;
            height: 40px;
            background: rgba(255, 255, 255, 0.9);
            -webkit-backdrop-filter: blur(10px);
            backdrop-filter: blur(10px);
            border-radius: 50%;
            border: 1px solid rgba(226, 232, 240, 0.6);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            z-index: 100;
        }

        .background-toggle:hover {
            background: rgba(255, 255, 255, 1);
            transform: scale(1.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        .background-toggle i {
            font-size: 18px;
            color: var(--accent);
            transition: color 0.3s ease;
        }

        .background-toggle:hover i {
            color: var(--accent-hover);
        }

        .colorize-toggle {
            position: absolute;
            top: 66px;
            left: 16px;
            width: 40px;
            height: 40px;
            background: rgba(255, 255, 255, 0.9);
            -webkit-backdrop-filter: blur(10px);
            backdrop-filter: blur(10px);
            border-radius: 50%;
            border: 1px solid rgba(226, 232, 240, 0.6);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            z-index: 100;
        }

        .colorize-toggle:hover {
            background: rgba(255, 255, 255, 1);
            transform: scale(1.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        .colorize-toggle i {
            font-size: 18px;
            transition: color 0.3s ease;
        }

        .colorize-toggle.active {
            background: linear-gradient(135deg, #dbeafe 0%, #f3e8ff 50%, #ffe4e6 100%);
            border-color: rgba(14, 165, 233, 0.3);
        }

        .colorize-toggle.active:hover {
            background: linear-gradient(135deg, #bfdbfe 0%, #e9d5ff 50%, #fecdd3 100%);
        }

        .colorize-toggle.active i {
            color: var(--accent);
        }

        .colorize-toggle:not(.active) i {
            color: var(--secondary);
        }

        .colorize-toggle:hover i {
            color: var(--accent-hover);
        }

        .button-group {
            display: flex;
            gap: 16px;
            margin-top: auto;
        }

        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255, 255, 255, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10;
            -webkit-backdrop-filter: blur(4px);
            backdrop-filter: blur(4px);
            transition: all 0.3s ease;
        }

        .spinner {
            width: 48px;
            height: 48px;
            border: 4px solid rgba(14, 165, 233, 0.1);
            border-radius: 50%;
            border-top-color: var(--accent);
            animation: spin 1s cubic-bezier(0.5, 0, 0.5, 1) infinite;
        }

        .error-message {
            background: #fef2f2;
            color: #ef4444;
            padding: 16px 20px;
            border-radius: var(--radius-md);
            margin-bottom: 20px;
            border: 1px solid #fee2e2;
            font-size: 0.95rem;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 6px 12px;
            background: rgba(255, 255, 255, 0.5);
            border-radius: 20px;
            border: 1px solid rgba(0, 0, 0, 0.05);
            font-size: 0.85rem;
            color: var(--text-sub);
            transition: all 0.2s ease;
        }

        .legend-item:hover {
            background: #fff;
            transform: translateY(-1px);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.03);
        }

        @keyframes fadeInDown {
            from {
                opacity: 0;
                transform: translateY(-30px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        /* Tablet and below */
        @media (max-width: 1200px) {
            .main-content {
                grid-template-columns: 1fr;
            }

            .app-container {
                padding: 24px;
            }
        }

        /* Mobile and small tablets */
        @media (max-width: 768px) {
            .app-container {
                padding: 16px;
            }

            .header {
                margin-bottom: 32px;
            }

            .header h1 {
                font-size: 2.5rem;
            }

            .header p {
                font-size: 1rem;
            }

            .main-content {
                gap: 20px;
            }

            .card-header {
                padding: 16px 20px;
            }

            .card-content {
                padding: 20px;
                gap: 16px;
            }

            .card-title {
                font-size: 1rem;
            }

            .input-textarea {
                min-height: 250px;
                padding: 16px;
                font-size: 13px;
            }

            .CodeMirror {
                height: 300px !important;
                font-size: 13px;
            }

            .button-group {
                gap: 10px;
            }

            .btn {
                height: 44px;
                font-size: 13px;
            }

            .btn-sm {
                height: 38px;
                font-size: 13px;
            }

            .diagram-container {
                min-height: 400px;
                border-radius: var(--radius-md);
            }
        }

        /* Small mobile phones */
        @media (max-width: 480px) {
            .app-container {
                padding: 12px;
            }

            .header {
                margin-bottom: 24px;
            }

            .header h1 {
                font-size: 1.75rem;
                letter-spacing: -0.02em;
            }

            .header p {
                font-size: 0.875rem;
            }

            .main-content {
                gap: 16px;
            }

            .card {
                border-radius: var(--radius-md);
            }

            .card-header {
                padding: 12px 16px;
            }

            .card-content {
                padding: 16px;
                gap: 12px;
            }

            /* 隐藏ER预览区的提示文本和分隔符 */
            .card-header>div:last-child>div:first-child {
                display: none !important;
            }

            .card-header>div:last-child .ant-switch {
                transform: scale(0.85);
            }

            /* 手机版隐藏图例 */
            .output-section .card-header>div:first-child {
                display: none !important;
            }

            /* 手机版控制区域居中 */
            .output-section .card-header {
                justify-content: center !important;
            }

            .output-section .card-header>div:last-child {
                margin: 0 !important;
                flex-wrap: wrap;
                gap: 8px !important;
                justify-content: center;
            }

            .card-title {
                font-size: 0.9rem;
            }

            .card-title span {
                font-size: 1.2rem !important;
            }

            .input-textarea {
                min-height: 200px;
                padding: 12px;
                font-size: 12px;
            }

            .CodeMirror {
                height: 250px !important;
                font-size: 12px;
            }

            .button-group {
                gap: 8px;
            }

            .btn {
                height: 40px;
                font-size: 12px;
                padding: 0 12px;
            }

            .btn-sm {
                height: 32px;
                font-size: 11px;
                padding: 0 10px;
                gap: 4px;
            }

            .diagram-container {
                min-height: 300px;
                border-radius: 12px;
                background-size: 16px 16px;
            }

            .legend-item {
                font-size: 0.75rem;
                padding: 4px 10px;
            }

            .error-message {
                padding: 12px 16px;
                font-size: 0.875rem;
            }

            /* 隐藏ER预览标头中的提示文本和分隔符 */
            .output-section .card-header>div:last-child>div:first-child,
            .output-section .card-header>div:last-child>div:nth-child(2) {
                display: none;
            }

            /* 手机版隐藏图例 */
            .output-section .card-header>div:first-child {
                display: none !important;
            }

            /* 手机版控制区域居中 */
            .output-section .card-header {
                justify-content: center !important;
            }

            .output-section .card-header>div:last-child {
                margin: 0 !important;
                flex-wrap: wrap;
                gap: 8px !important;
                justify-content: center;
            }
        }

        .CodeMirror {
            height: 480px !important;
            font-family: var(--font-mono) !important;
            font-size: 14px;
            line-height: 1.6;
            background: #fff;
        }

        .CodeMirror-gutters {
            background: #f8fafc;
            border-right: 1px solid #e2e8f0;
        }

        .CodeMirror-linenumber {
            color: #94a3b8;
        }

        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: transparent;
        }

        ::-webkit-scrollbar-thumb {
            background: #cbd5e1;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #94a3b8;
        }

        /* GitHub Corner - 立体纸张折叠效果 */
        .github-corner {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 9999;
            border: 0;
            width: 80px;
            height: 80px;
            overflow: hidden;
        }

        .github-corner svg {
            fill: #0f172a;
            color: #fff;
            position: absolute;
            top: 0;
            border: 0;
            left: 0;
            transition: all 0.3s ease;
            filter: drop-shadow(2px 2px 4px rgba(0, 0, 0, 0.2));
            transform: scaleX(-1);
        }

        /* 纸张折叠效果 - 上层阴影 */
        .github-corner::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 0;
            height: 0;
            border-style: solid;
            border-width: 80px 80px 0 0;
            border-color: rgba(15, 23, 42, 0.05) transparent transparent transparent;
            pointer-events: none;
            transition: all 0.3s ease;
        }

        /* 纸张折叠效果 - 下层阴影 */
        .github-corner::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 0;
            height: 0;
            border-style: solid;
            border-width: 0 0 80px 80px;
            border-color: transparent transparent rgba(0, 0, 0, 0.03) transparent;
            pointer-events: none;
            transition: all 0.3s ease;
            transform-origin: top left;
        }

        .github-corner:hover::before {
            border-color: rgba(15, 23, 42, 0.1) transparent transparent transparent;
        }

        .github-corner:hover::after {
            border-color: transparent transparent rgba(0, 0, 0, 0.06) transparent;
        }

        .github-corner:hover svg {
            filter: drop-shadow(3px 3px 6px rgba(0, 0, 0, 0.3));
            transform: scaleX(-1.05) scaleY(1.05);
        }

        .github-corner .octo-arm {
            transform-origin: 130px 106px;
        }

        .github-corner:hover .octo-arm {
            animation: octocat-wave 560ms ease-in-out;
        }

        @keyframes octocat-wave {

            0%,
            100% {
                transform: rotate(0);
            }

            20%,
            60% {
                transform: rotate(-25deg);
            }

            40%,
            80% {
                transform: rotate(10deg);
            }
        }

        @media (max-width: 500px) {
            .github-corner:hover .octo-arm {
                animation: none;
            }

            .github-corner .octo-arm {
                animation: octocat-wave 560ms ease-in-out;
            }

            .github-corner {
                width: 60px;
                height: 60px;
            }

            .github-corner svg {
                width: 60px;
                height: 60px;
            }
        }
    </style>
</head>

<body>
    <a href="https://github.com/ystemsrx/ER_diagram_generator" class="github-corner" aria-label="View source on GitHub"
        target="_blank" rel="noopener noreferrer">
        <svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true">
            <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
            <path
                d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
                fill="currentColor" class="octo-arm"></path>
            <path
                d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
                fill="currentColor" class="octo-body"></path>
        </svg>
    </a>
    <div class="app-container">
        <div class="header">
            <h1>SQL/DBML转ER图生成器</h1>
            <p>基于Chen模型的数据库设计工具</p>
        </div>

        <div id="root"></div>
    </div>

    <!-- Dependencies -->
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://unpkg.com/dayjs@1.11.10/dayjs.min.js"></script>
    <script src="https://unpkg.com/antd@5.19.1/dist/antd.min.js"></script>
    <script src="https://unpkg.com/@antv/g6@4.8.24/dist/g6.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/codemirror.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/sql/sql.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/javascript/javascript.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/addon/display/placeholder.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/addon/edit/matchbrackets.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/addon/edit/closebrackets.min.js"></script>

    <!-- Main Application Script -->
    <script type="text/babel">
        window.addEventListener('load', () => {
            const { useState, useEffect, useRef } = React;
            const { Switch } = window.antd;
            const G6 = window.G6;

            // Simple SQL Parser for CREATE TABLE statements
            const parseSQLTables = (sql) => {
                const tables = [];
                const relationships = [];

                // Remove comments and normalize whitespace
                const cleanSql = sql
                    .replace(/--.*$/gm, '')
                    .replace(/\/\*[\s\S]*?\*\//g, '')
                    .trim();

                // Split SQL into individual statements. This is more robust.
                const statements = cleanSql.split(';').filter(s => s.trim());

                statements.forEach(statement => {
                    // We only care about CREATE TABLE statements
                    const createTableMatch = statement.match(/^\s*CREATE\s+TABLE/i);
                    if (!createTableMatch) {
                        return;
                    }

                    // Extract table name
                    const tableNameMatch = statement.match(/CREATE\s+TABLE\s+(?:IF\s+NOT\s+EXISTS\s+)?\`?([\w\u4e00-\u9fa5]+)\`?/i);
                    if (!tableNameMatch) return;

                    const tableName = tableNameMatch[1];

                    // Manually find the content within the main parentheses to avoid complex regex
                    const openParenIndex = statement.indexOf('(');
                    if (openParenIndex === -1) return;

                    let closeParenIndex = -1;
                    let parenDepth = 0;
                    for (let i = openParenIndex + 1; i < statement.length; i++) {
                        const char = statement[i];
                        if (char === '(') {
                            parenDepth++;
                        } else if (char === ')') {
                            if (parenDepth === 0) {
                                closeParenIndex = i;
                                break;
                            }
                            parenDepth--;
                        }
                    }

                    if (closeParenIndex === -1) {
                        return; // Malformed CREATE TABLE statement
                    }

                    const tableBody = statement.substring(openParenIndex + 1, closeParenIndex);

                    const columns = [];
                    const primaryKeys = [];
                    const foreignKeys = [];

                    // Split by commas, but be careful with nested parentheses for types like DECIMAL(10, 2)
                    const parts = [];
                    let currentPart = '';
                    let depth = 0;

                    for (let i = 0; i < tableBody.length; i++) {
                        const char = tableBody[i];
                        if (char === '(') depth++;
                        else if (char === ')') depth--;
                        else if (char === ',' && depth === 0) {
                            parts.push(currentPart.trim());
                            currentPart = '';
                            continue;
                        }
                        currentPart += char;
                    }
                    if (currentPart.trim()) parts.push(currentPart.trim());

                    parts.forEach(part => {
                        const trimmedPart = part.trim().replace(/,\s*$/, ''); // Clean trailing commas
                        if (!trimmedPart) return;

                        // Check for PRIMARY KEY constraint at the table level
                        if (/^PRIMARY\s+KEY\s*\((.*)\)/i.test(trimmedPart)) {
                            const pkMatch = trimmedPart.match(/^PRIMARY\s+KEY\s*\((.*)\)/i);
                            if (pkMatch) {
                                const pkColumns = pkMatch[1].split(',').map(col => col.trim().replace(/[`"']/g, ''));
                                primaryKeys.push(...pkColumns);
                            }
                        }
                        // Check for FOREIGN KEY constraint
                        else if (/^(?:CONSTRAINT\s+\S+\s+)?FOREIGN\s+KEY/i.test(trimmedPart)) {
                            const fkMatch = trimmedPart.match(/^(?:CONSTRAINT\s+\S+\s+)?FOREIGN\s+KEY\s*\(\s*\`?([\w\u4e00-\u9fa5]+)\`?\s*\)\s+REFERENCES\s+\`?([\w\u4e00-\u9fa5]+)\`?\s*\(\s*\`?([\w\u4e00-\u9fa5]+)\`?\s*\)/i);
                            if (fkMatch) {
                                foreignKeys.push({
                                    column: fkMatch[1],
                                    referencedTable: fkMatch[2],
                                    referencedColumn: fkMatch[3]
                                });
                            }
                        }
                        // Regular column definition
                        else if (/^(\`?[\w\u4e00-\u9fa5]+\`?)\s+/.test(trimmedPart)) {
                            const columnMatch = trimmedPart.match(/^(\`?[\w\u4e00-\u9fa5]+\`?)\s+(\w+(?:\(\d+(?:,\s*\d+)?\))?)(.*)/i);
                            if (columnMatch) {
                                const columnName = columnMatch[1].replace(/`/g, '');
                                const dataType = columnMatch[2];
                                const constraints = columnMatch[3] || '';

                                const isPrimaryKey = /PRIMARY\s+KEY/i.test(constraints);
                                if (isPrimaryKey) {
                                    primaryKeys.push(columnName);
                                }

                                columns.push({
                                    name: columnName,
                                    type: dataType,
                                    isPrimaryKey
                                });
                            }
                        }
                    });

                    tables.push({
                        name: tableName,
                        columns,
                        primaryKeys,
                        foreignKeys
                    });

                    // Add relationships
                    foreignKeys.forEach(fk => {
                        relationships.push({
                            from: tableName,
                            to: fk.referencedTable,
                            label: fk.column
                        });
                    });
                });

                return { tables, relationships };
            };

            // DBML Parser
            const parseDBML = (dbml) => {
                const tables = [];
                const relationships = [];

                // Remove comments and normalize whitespace
                const cleanDbml = dbml
                    .replace(/\/\/.*$/gm, '')
                    .replace(/\/\*[\s\S]*?\*\//g, '')
                    .trim();

                const tableRegex = /Table\s+`?([\w\u4e00-\u9fa5]+)`?(?:\s+as\s+`?([\w\u4e00-\u9fa5]+)`?)?\s*\{([\s\S]*?)\}/g;
                let tableMatch;

                while ((tableMatch = tableRegex.exec(cleanDbml)) !== null) {
                    const tableName = tableMatch[1];
                    const tableAlias = tableMatch[2];
                    const tableBody = tableMatch[3].trim();
                    const columns = [];
                    const primaryKeys = [];
                    const foreignKeys = [];

                    tableBody.split('\n').forEach(line => {
                        if (!line.trim()) return;

                        // Match `column_name` type [attributes]
                        const columnMatch = line.trim().match(/^`?([\w\u4e00-\u9fa5]+)`?\s+([\w\d\(\)\s,]+)(?:\s*\[([^\]]*)\])?/);

                        if (columnMatch) {
                            const columnName = columnMatch[1];
                            const columnType = columnMatch[2].trim();
                            const attributesStr = columnMatch[3] || '';

                            const isPrimaryKey = attributesStr.includes('pk') || attributesStr.includes('primary key');

                            if (isPrimaryKey) {
                                primaryKeys.push(columnName);
                            }

                            // Handle inline references
                            const refMatch = attributesStr.match(/ref:\s*(?:[-><])\s*`?([\w\u4e00-\u9fa5]+)`?\.`?([\w\u4e00-\u9fa5]+)`?/);
                            if (refMatch) {
                                const toTable = refMatch[1];
                                const toColumn = refMatch[2];

                                relationships.push({
                                    from: tableName,
                                    to: toTable,
                                    label: columnName
                                });

                                foreignKeys.push({
                                    column: columnName,
                                    referencedTable: toTable,
                                    referencedColumn: toColumn
                                });
                            }

                            columns.push({
                                name: columnName,
                                type: columnType,
                                isPrimaryKey: isPrimaryKey
                            });
                        }
                    });

                    tables.push({
                        name: tableName,
                        alias: tableAlias,
                        columns,
                        primaryKeys,
                        foreignKeys: foreignKeys
                    });
                }

                // 支持中文表名和列名的 Ref 语句
                const refRegex = /Ref\s*:\s*`?([\w\u4e00-\u9fa5]+)`?\.`?([\w\u4e00-\u9fa5]+)`?\s*[-><]\s*`?([\w\u4e00-\u9fa5]+)`?\.`?([\w\u4e00-\u9fa5]+)`?/g;
                let refMatch;

                while ((refMatch = refRegex.exec(cleanDbml)) !== null) {
                    const fromTable = refMatch[1];
                    const fromColumn = refMatch[2];
                    const toTable = refMatch[3];
                    const toColumn = refMatch[4];

                    relationships.push({
                        from: fromTable,
                        to: toTable,
                        label: fromColumn
                    });

                    const table = tables.find(t => t.name === fromTable);
                    if (table) {
                        if (!table.foreignKeys) {
                            table.foreignKeys = [];
                        }
                        table.foreignKeys.push({
                            column: fromColumn,
                            referencedTable: toTable,
                            referencedColumn: toColumn
                        });
                    }
                }

                return { tables, relationships };
            };

            // Generate Chen Model ER diagram data
            const generateChenModelData = (tables, relationships, isColored = true) => {
                const nodes = [];
                const edges = [];
                const entityMap = new Map(); // 用于存储表名到实体ID的映射

                // Create entity nodes (rectangles) - 不设置固定位置，让布局算法处理
                tables.forEach((table, tableIndex) => {
                    const entityId = `entity-${table.name}-${tableIndex}`;
                    entityMap.set(table.name, entityId); // 记录映射关系
                    if (table.alias) {
                        entityMap.set(table.alias, entityId);
                    }

                    nodes.push({
                        id: entityId,
                        type: 'entity',
                        label: table.name,
                        // 移除固定的x,y坐标，让布局算法自动处理
                        style: {
                            fill: '#ffffff',
                            stroke: isColored ? '#595959' : '#000000',
                            lineWidth: 2
                        },
                        labelCfg: {
                            style: {
                                fill: '#000000',
                                fontWeight: 'bold'
                            }
                        },
                        // 添加节点分类信息，用于布局算法
                        nodeType: 'entity'
                    });

                    // Create attribute nodes (ellipses) for each column
                    table.columns.forEach((column, colIndex) => {
                        const attributeId = `attr-${table.name}-${column.name}-${tableIndex}-${colIndex}`;
                        const isPrimaryKey = table.primaryKeys.includes(column.name) || column.isPrimaryKey;

                        nodes.push({
                            id: attributeId,
                            type: 'attribute',
                            label: column.name,
                            // 移除固定位置
                            keyType: isPrimaryKey ? 'pk' : 'normal',
                            style: {
                                fill: isColored ? (isPrimaryKey ? '#f6ffed' : '#fffbe6') : '#ffffff',
                                stroke: isColored ? (isPrimaryKey ? '#52c41a' : '#faad14') : '#000000',
                                lineWidth: isPrimaryKey ? 2 : 1
                            },
                            labelCfg: {
                                style: {
                                    fill: '#000000',
                                    fontWeight: isPrimaryKey ? 'bold' : 'normal'
                                }
                            },
                            nodeType: 'attribute',
                            parentEntity: entityId // 标记父实体
                        });

                        // Connect attribute to entity
                        edges.push({
                            id: `edge-${entityId}-${attributeId}-${tableIndex}-${colIndex}`,
                            source: entityId,
                            target: attributeId,
                            style: {
                                stroke: '#000000'
                            },
                            edgeType: 'entity-attribute'
                        });
                    });
                });

                // Create relationship nodes (diamonds) and connections
                relationships.forEach((rel, relIndex) => {
                    const relationshipId = `rel-${rel.from}-${rel.to}-${rel.label}-${relIndex}`;

                    nodes.push({
                        id: relationshipId,
                        type: 'relationship',
                        label: rel.label,
                        style: {
                            fill: isColored ? '#f9f0ff' : '#ffffff',
                            stroke: isColored ? '#722ed1' : '#000000',
                            lineWidth: 2
                        },
                        labelCfg: {
                            style: {
                                fill: '#000000'
                            }
                        },
                        nodeType: 'relationship'
                    });

                    // Connect source entity (the one with the FK, 'many' side) to relationship
                    edges.push({
                        id: `edge-entity-${rel.from}-${relationshipId}-${relIndex}-1`,
                        source: entityMap.get(rel.from),
                        target: relationshipId,
                        label: 'N',
                        style: {
                            stroke: '#000000',
                            lineWidth: 2
                        },
                        labelCfg: {
                            style: {
                                fill: '#000000',
                                background: {
                                    fill: '#ffffff',
                                    padding: [2, 4, 2, 4]
                                }
                            }
                        },
                        edgeType: 'entity-relationship'
                    });

                    // Connect relationship to target entity (the one being referenced, 'one' side)
                    edges.push({
                        id: `edge-${relationshipId}-entity-${rel.to}-${relIndex}-2`,
                        source: relationshipId,
                        target: entityMap.get(rel.to),
                        label: '1',
                        style: {
                            stroke: '#000000',
                            lineWidth: 2
                        },
                        labelCfg: {
                            style: {
                                fill: '#000000',
                                background: {
                                    fill: '#ffffff',
                                    padding: [2, 4, 2, 4]
                                }
                            }
                        },
                        edgeType: 'relationship-entity'
                    });
                });

                return { nodes, edges };
            };

            // Register custom node types for Chen model
            G6.registerNode('entity', {
                draw(cfg, group) {
                    const fontSize = 18;
                    const text = cfg.label || '';

                    // 计算文字尺寸，考虑中文字符
                    const getTextWidth = (text, fontSize) => {
                        let width = 0;
                        for (let char of text) {
                            // 中文字符宽度约等于字体大小，英文字符约为字体大小的0.6倍
                            if (/[\u4e00-\u9fa5]/.test(char)) {
                                width += fontSize;
                            } else {
                                width += fontSize * 0.6;
                            }
                        }
                        return width;
                    };

                    const textWidth = getTextWidth(text, fontSize);
                    const padding = 10; // 水平内边距，从20减小到10
                    const minWidth = 80; // 最小宽度
                    const minHeight = 50; // 最小高度

                    const width = Math.max(minWidth, textWidth + padding * 2);
                    const height = Math.max(minHeight, fontSize + 20); // 垂直内边距

                    const shape = group.addShape('rect', {
                        attrs: {
                            x: -width / 2,
                            y: -height / 2,
                            width: width,
                            height: height,
                            fill: cfg.style?.fill || '#fff',
                            stroke: cfg.style?.stroke || '#000',
                            lineWidth: cfg.style?.lineWidth || 2
                        },
                        name: 'entity-shape'
                    });

                    if (cfg.label) {
                        group.addShape('text', {
                            attrs: {
                                x: 0,
                                y: 0,
                                text: cfg.label,
                                fontSize: fontSize,
                                textAlign: 'center',
                                textBaseline: 'middle',
                                fill: '#000',
                                fontWeight: 'bold'
                            },
                            name: 'entity-text',
                            capture: false
                        });
                    }

                    return shape;
                }
            });

            G6.registerNode('attribute', {
                draw(cfg, group) {
                    const fontSize = 15;
                    const text = cfg.label || '';

                    // 计算文字尺寸，考虑中文字符
                    const getTextWidth = (text, fontSize) => {
                        let width = 0;
                        for (let char of text) {
                            // 中文字符宽度约等于字体大小，英文字符约为字体大小的0.6倍
                            if (/[\u4e00-\u9fa5]/.test(char)) {
                                width += fontSize;
                            } else {
                                width += fontSize * 0.6;
                            }
                        }
                        return width;
                    };

                    const textWidth = getTextWidth(text, fontSize);
                    const padding = 16; // 水平内边距
                    const minWidth = 60; // 最小宽度
                    const minHeight = 40; // 最小高度

                    const width = Math.max(minWidth, textWidth + padding * 2);
                    const height = Math.max(minHeight, fontSize + 16); // 垂直内边距

                    const shape = group.addShape('ellipse', {
                        attrs: {
                            x: 0,
                            y: 0,
                            rx: width / 2,
                            ry: height / 2,
                            fill: cfg.style?.fill || '#fff',
                            stroke: cfg.style?.stroke || '#000',
                            lineWidth: cfg.style?.lineWidth || 1
                        },
                        name: 'attribute-shape'
                    });

                    if (cfg.label) {
                        const isPrimaryKey = cfg.keyType === 'pk';
                        group.addShape('text', {
                            attrs: {
                                x: 0,
                                y: 0,
                                text: cfg.label,
                                fontSize: fontSize,
                                textAlign: 'center',
                                textBaseline: 'middle',
                                fill: '#000',
                                fontWeight: isPrimaryKey ? 'bold' : 'normal'
                            },
                            name: 'attribute-text',
                            capture: false
                        });

                        // Add underline for primary keys
                        if (isPrimaryKey) {
                            const textWidth = getTextWidth(text, fontSize); // 使用精确的文字宽度计算
                            group.addShape('line', {
                                attrs: {
                                    x1: -textWidth / 2,
                                    y1: 12, // 下划线位置
                                    x2: textWidth / 2,
                                    y2: 12,
                                    stroke: '#000',
                                    lineWidth: 1
                                },
                                name: 'attribute-underline'
                            });
                        }
                    }

                    return shape;
                }
            });

            G6.registerNode('relationship', {
                draw(cfg, group) {
                    const fontSize = 16;
                    const text = cfg.label || '';

                    // 计算文字尺寸，考虑中文字符
                    const getTextWidth = (text, fontSize) => {
                        let width = 0;
                        for (let char of text) {
                            // 中文字符宽度约等于字体大小，英文字符约为字体大小的0.6倍
                            if (/[\u4e00-\u9fa5]/.test(char)) {
                                width += fontSize;
                            } else {
                                width += fontSize * 0.6;
                            }
                        }
                        return width;
                    };

                    const textWidth = getTextWidth(text, fontSize);
                    const horizontalPadding = 24; // 水平内边距
                    const verticalPadding = 16; // 垂直内边距
                    const minWidth = 80; // 最小宽度
                    const minHeight = 40; // 最小高度

                    // 计算菱形的实际宽度和高度
                    // 菱形是扁的，宽度要比高度大
                    const requiredWidth = textWidth + horizontalPadding * 2;
                    const requiredHeight = fontSize + verticalPadding * 2;

                    // 菱形的水平半径（宽度的一半）
                    const halfWidth = Math.max(minWidth / 2, requiredWidth / 2);
                    // 菱形的垂直半径（高度的一半），设置为宽度的0.6倍，让菱形变扁
                    const halfHeight = Math.max(minHeight / 2, Math.min(halfWidth * 0.6, requiredHeight / 2));

                    const shape = group.addShape('polygon', {
                        attrs: {
                            points: [
                                [0, -halfHeight],        // 上顶点
                                [halfWidth, 0],          // 右顶点  
                                [0, halfHeight],         // 下顶点
                                [-halfWidth, 0]          // 左顶点
                            ],
                            fill: cfg.style?.fill || '#fff',
                            stroke: cfg.style?.stroke || '#000',
                            lineWidth: cfg.style?.lineWidth || 2
                        },
                        name: 'relationship-shape'
                    });

                    if (cfg.label) {
                        group.addShape('text', {
                            attrs: {
                                x: 0,
                                y: 0,
                                text: cfg.label,
                                fontSize: fontSize,
                                textAlign: 'center',
                                textBaseline: 'middle',
                                fill: '#000'
                            },
                            name: 'relationship-text',
                            capture: false
                        });
                    }

                    return shape;
                }
            });

            const CodeEditor = ({ value, onChange, placeholder }) => {
                const editorRef = useRef(null);
                const cmInstance = useRef(null);

                useEffect(() => {
                    if (!editorRef.current) return;

                    cmInstance.current = CodeMirror.fromTextArea(editorRef.current, {
                        mode: "text/x-sql",
                        lineNumbers: true,
                        theme: "default",
                        lineWrapping: true,
                        height: "480px",
                        placeholder: placeholder,
                        matchBrackets: true,
                        autoCloseBrackets: true
                    });

                    cmInstance.current.on('change', (cm) => {
                        const newValue = cm.getValue();
                        onChange(newValue);
                    });

                    cmInstance.current.setValue(value);

                    return () => {
                        if (cmInstance.current) {
                            cmInstance.current.toTextArea();
                        }
                    };
                }, []);

                useEffect(() => {
                    if (cmInstance.current && cmInstance.current.getValue() !== value) {
                        const cursor = cmInstance.current.getCursor();
                        cmInstance.current.setValue(value);
                        cmInstance.current.setCursor(cursor);
                    }
                }, [value]);

                return (
                    <div style={{ height: '480px', display: 'flex', flexDirection: 'column', border: '1px solid #e2e8f0', borderRadius: '16px', overflow: 'hidden' }}>
                        <textarea ref={editorRef} style={{ display: 'none' }} />
                    </div>
                );
            };

            const App = () => {
                const [showBackground, setShowBackground] = useState(true);
                const [inputText, setInputText] = useState(`// 示例DBML，请在此处粘贴您的 DBML 或 SQL 语句
Table 用户 {
  编号 INT [pk, increment]
  用户名 VARCHAR(255) [not null]
  邮箱 VARCHAR(255) [unique]
  创建时间 TIMESTAMP
}

Table 国家 {
  编号 INT [pk]
  名称 VARCHAR(255) [not null]
}

Table 文章 {
  文章编号 INT [pk]
  内容 TEXT
}

Ref: 用户.属于 > 国家.编号
Ref: 文章.作者 > 用户.编号
`);
                const [isColored, setIsColored] = useState(true);
                const [error, setError] = useState(null);
                const [loading, setLoading] = useState(false);
                const [hasGraph, setHasGraph] = useState(false);
                const lastInputRef = useRef(''); // 记录上次生成时的输入
                const containerRef = useRef(null);
                const graphRef = useRef(null);

                // 更新图表样式
                const updateGraphStyles = (graphInstance, colored) => {
                    if (!graphInstance || graphInstance.destroyed) return;

                    graphInstance.setAutoPaint(false);

                    const nodes = graphInstance.getNodes();
                    nodes.forEach(node => {
                        const model = node.getModel();
                        const styles = {};

                        if (colored) {
                            if (model.nodeType === 'entity') {
                                // Sky Blue theme
                                styles.style = {
                                    fill: '#e0f2fe',
                                    stroke: '#0ea5e9',
                                    lineWidth: 2,
                                    radius: 8,
                                    shadowColor: 'rgba(14, 165, 233, 0.2)',
                                    shadowBlur: 10
                                };
                                styles.labelCfg = { style: { fill: '#0f172a', fontWeight: '700', fontFamily: 'Inter' } };
                            } else if (model.nodeType === 'relationship') {
                                // Violet theme
                                styles.style = {
                                    fill: '#f5f3ff',
                                    stroke: '#8b5cf6',
                                    lineWidth: 2,
                                    shadowColor: 'rgba(139, 92, 246, 0.2)',
                                    shadowBlur: 10
                                };
                                styles.labelCfg = { style: { fill: '#0f172a', fontFamily: 'Inter' } };
                            } else if (model.nodeType === 'attribute') {
                                if (model.keyType === 'pk') {
                                    // Emerald theme
                                    styles.style = {
                                        fill: '#ecfdf5',
                                        stroke: '#10b981',
                                        lineWidth: 2,
                                        shadowColor: 'rgba(16, 185, 129, 0.2)',
                                        shadowBlur: 5
                                    };
                                    styles.labelCfg = { style: { fill: '#0f172a', fontWeight: '700', fontFamily: 'Inter' } };
                                } else {
                                    // Slate theme
                                    styles.style = {
                                        fill: '#ffffff',
                                        stroke: '#94a3b8', // Slate 400
                                        lineWidth: 2
                                    };
                                    styles.labelCfg = { style: { fill: '#475569', fontWeight: 'normal', fontFamily: 'Inter' } };
                                }
                            }
                        } else {
                            // 黑白模式 (无填充 = 白色背景)
                            styles.style = {
                                fill: '#ffffff',
                                stroke: '#1e293b',
                                lineWidth: model.keyType === 'pk' || model.nodeType === 'entity' || model.nodeType === 'relationship' ? 2 : 1,
                                shadowBlur: 0
                            };
                            styles.labelCfg = { style: { fill: '#1e293b', fontWeight: (model.nodeType === 'entity' || model.keyType === 'pk') ? 'bold' : 'normal', fontFamily: 'Inter' } };
                        }

                        graphInstance.updateItem(node, styles);
                    });

                    // 刷新边
                    const edges = graphInstance.getEdges();
                    edges.forEach(edge => {
                        graphInstance.updateItem(edge, {
                            style: {
                                stroke: '#000000',
                                lineWidth: 1.5,
                                endArrow: false
                            },
                            labelCfg: {
                                style: {
                                    fill: '#000000',
                                    fontSize: 12,
                                    background: {
                                        fill: '#ffffff',
                                        padding: [2, 4, 2, 4],
                                        radius: 2
                                    }
                                }
                            }
                        });
                    });

                    graphInstance.paint();
                    graphInstance.setAutoPaint(true);
                };

                // 监听着色状态变化
                useEffect(() => {
                    if (hasGraph && graphRef.current) {
                        updateGraphStyles(graphRef.current, isColored);
                    }
                }, [isColored, hasGraph]);

                // 真正有效的平滑缩放函数
                const smoothFitView = (graph, duration = 800, easing = 'easeOutCubic') => {
                    if (!graph || graph.destroyed) return;

                    try {
                        // 获取所有节点的边界框
                        const nodes = graph.getNodes();
                        if (!nodes || nodes.length === 0) {
                            graph.fitView(20);
                            return;
                        }

                        // 计算所有节点的总体边界框
                        let minX = Infinity, maxX = -Infinity;
                        let minY = Infinity, maxY = -Infinity;

                        nodes.forEach(node => {
                            const bbox = node.getBBox();
                            minX = Math.min(minX, bbox.minX);
                            maxX = Math.max(maxX, bbox.maxX);
                            minY = Math.min(minY, bbox.minY);
                            maxY = Math.max(maxY, bbox.maxY);
                        });

                        // 边界框的宽度和高度
                        const contentWidth = maxX - minX;
                        const contentHeight = maxY - minY;
                        const contentCenterX = (minX + maxX) / 2;
                        const contentCenterY = (minY + maxY) / 2;

                        if (contentWidth === 0 || contentHeight === 0) {
                            graph.fitView(20);
                            return;
                        }

                        // 画布尺寸
                        const graphWidth = graph.get('width');
                        const graphHeight = graph.get('height');
                        const padding = 40; // 边距

                        // 计算合适的缩放比例，让内容完全显示在画布内，且尽可能大
                        const scaleX = (graphWidth - padding * 2) / contentWidth;
                        const scaleY = (graphHeight - padding * 2) / contentHeight;
                        const targetZoom = Math.min(scaleX, scaleY);

                        // 计算目标平移，让内容居中显示
                        // 在新的缩放比例下，内容中心应该对应到画布中心
                        const targetCenterX = graphWidth / 2 - contentCenterX * targetZoom;
                        const targetCenterY = graphHeight / 2 - contentCenterY * targetZoom;

                        // 获取当前状态
                        const currentZoom = graph.getZoom();
                        const currentMatrix = graph.get('group').getMatrix();
                        const currentCenterX = currentMatrix ? currentMatrix[6] : 0;
                        const currentCenterY = currentMatrix ? currentMatrix[7] : 0;

                        // 执行平滑动画
                        const startTime = performance.now();

                        const animate = (currentTime) => {
                            if (!graph || graph.destroyed) return;

                            const elapsed = currentTime - startTime;
                            let progress = Math.min(elapsed / duration, 1);

                            // 缓动函数
                            if (easing === 'easeOutQuart') {
                                progress = 1 - Math.pow(1 - progress, 4);
                            } else { // easeOutCubic
                                progress = 1 - Math.pow(1 - progress, 3);
                            }

                            // 计算当前帧的值
                            const frameZoom = currentZoom + (targetZoom - currentZoom) * progress;
                            const frameCenterX = currentCenterX + (targetCenterX - currentCenterX) * progress;
                            const frameCenterY = currentCenterY + (targetCenterY - currentCenterY) * progress;

                            // 应用变换
                            const groupMatrix = [frameZoom, 0, 0, 0, frameZoom, 0, frameCenterX, frameCenterY, 1];
                            graph.get('group').setMatrix(groupMatrix);
                            graph.paint();

                            // 继续动画
                            if (progress < 1) {
                                requestAnimationFrame(animate);
                            }
                        };

                        requestAnimationFrame(animate);

                    } catch (error) {
                        console.warn('Smooth fit view failed, falling back to instant fit:', error);
                        graph.fitView(20);
                    }
                };

                // 基于目标坐标的节点平滑移动
                const animateNodesToTargets = (graph, targets, duration = 800, onFinish) => {
                    if (!graph || graph.destroyed || !targets?.size) {
                        if (onFinish) onFinish();
                        return;
                    }

                    const startPositions = new Map();
                    graph.getNodes().forEach(node => {
                        const model = node.getModel();
                        startPositions.set(model.id, { x: model.x, y: model.y });
                    });

                    const startTime = performance.now();
                    graph.setAutoPaint(false);

                    const step = (currentTime) => {
                        if (!graph || graph.destroyed) return;
                        const elapsed = currentTime - startTime;
                        const rawProgress = Math.min(elapsed / duration, 1);
                        const progress = 1 - Math.pow(1 - rawProgress, 3); // easeOutCubic

                        targets.forEach((target, id) => {
                            const node = graph.findById(id);
                            if (!node) return;
                            const start = startPositions.get(id) || target;
                            const x = start.x + (target.x - start.x) * progress;
                            const y = start.y + (target.y - start.y) * progress;
                            graph.updateItem(node, { x, y });
                        });

                        graph.paint();

                        if (rawProgress < 1) {
                            requestAnimationFrame(step);
                        } else {
                            graph.setAutoPaint(true);
                            if (onFinish) onFinish();
                        }
                    };

                    requestAnimationFrame(step);
                };

                // 基于字符串生成确定性哈希值（用于替代Math.random）
                const deterministicHash = (str, extraSeed = 0) => {
                    let hash = extraSeed; // 加入额外的种子
                    for (let i = 0; i < str.length; i++) {
                        const char = str.charCodeAt(i);
                        hash = ((hash << 5) - hash) + char;
                        hash = hash & hash; // 转换为32位整数
                    }
                    return Math.abs(hash);
                };

                // 生成确定性的[-0.5, 0.5)范围内的数值
                const deterministicRandom = (seed, extraSeed = 0) => {
                    const x = Math.sin(seed + extraSeed * 1000) * 10000;
                    return (x - Math.floor(x)) - 0.5;
                };

                // 初始定位：让互不相连的组件一开始就围绕中心分布，避免先交叉再分散
                const applyInitialComponentPositions = (nodes, edges, containerEl, seed = 0) => {
                    if (!containerEl || !nodes.length) return;
                    if (nodes.length < 2) return;

                    const width = containerEl.offsetWidth || 1200;
                    const height = containerEl.offsetHeight || 800;
                    const center = { x: width / 2, y: height / 2 };

                    const sizeMap = {
                        entity: 140,
                        relationship: 90,
                        attribute: 90
                    };

                    const approxRadius = (node) => {
                        const size = sizeMap[node.nodeType] || 90;
                        return Math.sqrt(size * size * 2) / 2 + 20;
                    };

                    // 构建无向邻接表
                    const adj = new Map();
                    edges.forEach(e => {
                        const { source, target } = e;
                        if (!adj.has(source)) adj.set(source, new Set());
                        if (!adj.has(target)) adj.set(target, new Set());
                        adj.get(source).add(target);
                        adj.get(target).add(source);
                    });

                    // 划分组件（按ID排序以确保稳定性）
                    const visited = new Set();
                    const components = [];
                    const sortedNodes = [...nodes].sort((a, b) => a.id.localeCompare(b.id));
                    sortedNodes.forEach(n => {
                        if (visited.has(n.id)) return;
                        const stack = [n.id];
                        const comp = [];
                        visited.add(n.id);
                        while (stack.length) {
                            const cur = stack.pop();
                            const found = nodes.find(nn => nn.id === cur);
                            if (found) comp.push(found);
                            const neighbors = adj.get(cur);
                            if (!neighbors) continue;
                            // 对邻居节点也进行排序以确保DFS顺序稳定
                            const sortedNeighbors = Array.from(neighbors).sort((a, b) => a.localeCompare(b));
                            sortedNeighbors.forEach(nb => {
                                if (!visited.has(nb)) {
                                    visited.add(nb);
                                    stack.push(nb);
                                }
                            });
                        }
                        if (comp.length) components.push(comp);
                    });

                    if (components.length < 2) return;

                    // 估算每个组件半径
                    const compMeta = components.map(list => {
                        const r = list.reduce((max, n) => Math.max(max, approxRadius(n)), 30);
                        const extra = Math.max(0, list.length - 6) * 6;
                        return { nodes: list, radius: r + extra };
                    });

                    const perim = compMeta.reduce((sum, c) => sum + c.radius * 2, 0);
                    const gap = 100;
                    const orbit = Math.min(
                        Math.max(240, (perim + gap * compMeta.length) / (2 * Math.PI)),
                        520 // 不要飞得太远
                    );

                    let angle = -Math.PI / 2;
                    const angleStep = (Math.PI * 2) / compMeta.length;
                    compMeta.forEach(meta => {
                        const cx = center.x + orbit * Math.cos(angle);
                        const cy = center.y + orbit * Math.sin(angle);
                        // 组件内部使用确定性偏移，避免完全重叠且保证每次生成相同
                        meta.nodes.forEach((n, idx) => {
                            const hash = deterministicHash(n.id, seed);
                            const offsetX = deterministicRandom(hash, seed) * Math.max(40, meta.radius * 0.4);
                            const offsetY = deterministicRandom(hash + 1000, seed) * Math.max(40, meta.radius * 0.4);
                            n.x = cx + offsetX;
                            n.y = cy + offsetY;
                        });
                        angle += angleStep;
                    });
                };

                // 将互不相连的组件分散到中心周围，避免首屏交叉
                const spreadDisconnectedComponents = (graph, onFinish) => {
                    if (!graph || graph.destroyed) {
                        if (onFinish) onFinish();
                        return;
                    }
                    const nodes = graph.getNodes();
                    if (nodes.length < 2) {
                        if (onFinish) onFinish();
                        return;
                    }

                    // 建立无向邻接表
                    const adj = new Map();
                    graph.getEdges().forEach(edge => {
                        const { source, target } = edge.getModel();
                        if (!adj.has(source)) adj.set(source, new Set());
                        if (!adj.has(target)) adj.set(target, new Set());
                        adj.get(source).add(target);
                        adj.get(target).add(source);
                    });

                    // DFS 拆出组件（按ID排序以确保稳定性）
                    const visited = new Set();
                    const components = [];
                    const sortedNodes = [...nodes].sort((a, b) => a.getModel().id.localeCompare(b.getModel().id));
                    sortedNodes.forEach(node => {
                        const id = node.getModel().id;
                        if (visited.has(id)) return;
                        const stack = [id];
                        const comp = [];
                        visited.add(id);
                        while (stack.length) {
                            const cur = stack.pop();
                            const curNode = graph.findById(cur);
                            if (curNode) comp.push(curNode);
                            const neighbors = adj.get(cur);
                            if (!neighbors) continue;
                            // 对邻居节点也进行排序以确保DFS顺序稳定
                            const sortedNeighbors = Array.from(neighbors).sort((a, b) => a.localeCompare(b));
                            sortedNeighbors.forEach(nid => {
                                if (!visited.has(nid)) {
                                    visited.add(nid);
                                    stack.push(nid);
                                }
                            });
                        }
                        if (comp.length) components.push(comp);
                    });

                    if (components.length < 2) {
                        if (onFinish) onFinish();
                        return; // 只有一个连通块无需分散
                    }

                    const diagramCenter = {
                        x: graph.get('width') / 2,
                        y: graph.get('height') / 2
                    };

                    const targets = new Map();

                    // 组件的大小与半径
                    const compMeta = components.map(comp => {
                        let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
                        let cx = 0, cy = 0;
                        comp.forEach(n => {
                            const bbox = n.getBBox();
                            minX = Math.min(minX, bbox.minX);
                            maxX = Math.max(maxX, bbox.maxX);
                            minY = Math.min(minY, bbox.minY);
                            maxY = Math.max(maxY, bbox.maxY);
                            cx += bbox.centerX;
                            cy += bbox.centerY;
                        });
                        const width = Math.max(40, maxX - minX);
                        const height = Math.max(40, maxY - minY);
                        const radius = Math.sqrt(width * width + height * height) / 2 + 40; // 额外留白
                        const center = {
                            x: cx / comp.length,
                            y: cy / comp.length
                        };
                        return { comp, radius, center };
                    });

                    // 根据周长分配角度，半径足够大避免互相穿插
                    const gap = 50;
                    const totalSpan = compMeta.reduce((sum, c) => sum + c.radius * 2 + gap, 0);
                    const orbitRadius = Math.min(
                        Math.max(
                            totalSpan / (2 * Math.PI),
                            Math.max(...compMeta.map(c => c.radius)) + gap + 40,
                            240
                        ),
                        520
                    );

                    let angleCursor = -Math.PI / 2;
                    compMeta.forEach(meta => {
                        const angleSpan = ((meta.radius * 2 + gap) / totalSpan) * Math.PI * 2;
                        const midAngle = angleCursor + angleSpan / 2;

                        // 将组件整体移动到环形位置，并旋转到切向方向，避免“穿过中心”的直线
                        const targetCenter = {
                            x: diagramCenter.x + orbitRadius * Math.cos(midAngle),
                            y: diagramCenter.y + orbitRadius * Math.sin(midAngle)
                        };
                        const rotateAngle = midAngle + Math.PI / 2;
                        const cosA = Math.cos(rotateAngle);
                        const sinA = Math.sin(rotateAngle);

                        meta.comp.forEach(node => {
                            const m = node.getModel();
                            const relX = m.x - meta.center.x;
                            const relY = m.y - meta.center.y;
                            const rx = relX * cosA - relY * sinA;
                            const ry = relX * sinA + relY * cosA;
                            targets.set(m.id, {
                                x: targetCenter.x + rx,
                                y: targetCenter.y + ry
                            });
                        });

                        angleCursor += angleSpan;
                    });

                    animateNodesToTargets(graph, targets, 450, onFinish);
                };

                const handleGenerate = () => {
                    try {
                        setError(null);
                        setLoading(true);

                        if (!inputText.trim()) {
                            setError("输入为空。");
                            setLoading(false);
                            return;
                        }

                        // 如果输入改变了，记录新输入
                        if (lastInputRef.current !== inputText.trim()) {
                            lastInputRef.current = inputText.trim();
                        }

                        let parsedData;
                        const potentialSQL = inputText.trim();

                        // Try parsing as SQL first, if it fails (no tables), try DBML.
                        parsedData = parseSQLTables(potentialSQL);

                        if (parsedData.tables.length === 0) {
                            parsedData = parseDBML(potentialSQL);
                        }

                        const { tables, relationships } = parsedData;

                        if (tables.length === 0) {
                            setError("未找到有效的 CREATE TABLE 或 Table 定义。请确保您的SQL或DBML语法正确。");
                            setLoading(false);
                            return;
                        }

                        const { nodes, edges } = generateChenModelData(tables, relationships, isColored);

                        // 初始位置：先把不同组件分开围绕中心，避免初始交叉
                        applyInitialComponentPositions(nodes, edges, containerRef.current, 0);

                        // Clear previous graph completely
                        if (graphRef.current) {
                            graphRef.current.clear(); // 先清空数据
                            graphRef.current.destroy(); // 再销毁图形
                            graphRef.current = null; // 重置引用
                        }

                        // Create G6 graph
                        const graph = new G6.Graph({
                            container: containerRef.current,
                            width: containerRef.current.offsetWidth,
                            height: containerRef.current.offsetHeight,
                            renderer: 'canvas',
                            background: '#ffffff', // 设置白色背景，确保复制图片时背景为白色
                            modes: {
                                default: [
                                    'drag-node',                         // 1. 先判断拖节点
                                    {
                                        type: 'drag-canvas',
                                        allowDragOnItem: true,             // 2. 允许在 item 上拖画布
                                        enableOptimize: false,              //    （性能优化，可留可删）
                                        shouldBegin(e) {                   // 3. 自定义开始条件
                                            // e.item 为空 = 真空白处；组合 / 边也算"非 node"
                                            return !e.item || e.item.getType() !== 'node';
                                        }
                                    },
                                    'zoom-canvas'
                                ]
                            },

                            // 优化后的力导向布局配置，以完全避免重叠
                            layout: {
                                type: 'force', // 使用普通 force 布局
                                preventOverlap: true, // 确保节点不重叠
                                // 忽略文本长度，统一处理椭圆/菱形尺寸，避免因内容长短造成布局偏差
                                nodeSize: (node) => {
                                    const uniformSizes = {
                                        entity: 140,
                                        relationship: 90,
                                        attribute: 90
                                    };
                                    return uniformSizes[node.nodeType] || 90;
                                },
                                nodeSpacing: 20,     // 增加节点间距，为曲线路由留空间
                                nodeStrength: -130,  // 斥力提高，为曲线路由留更多空间
                                edgeStrength: 0.9,   // 略减弱拉力，让路由有更多选择
                                linkDistance: 120,   // 增加连线长度，为曲线留空间
                                collideStrength: 1.0, // 使用最强的碰撞检测力，严格防止重叠
                                alpha: 0.75,          // 初始运动强度
                                alphaDecay: 0.045,    // 更快衰减以加速初始布局，但仍可看到调整过程
                                alphaMin: 0.01,       // 停止阈值略放宽，加快收敛
                                maxIteration: 800,    // 控制迭代次数，提高迭代步数以获得更优的布局
                                center: [containerRef.current.offsetWidth / 2, 300], // 动态设置布局中心
                                gravity: 8,           // 降低重心力以增加节点间距
                                tick: () => {
                                    // 逐帧刷新以展现自动调整过程
                                    graph.refreshPositions();
                                },
                                onLayoutEnd: () => {
                                    // 先让互不相连的组件环绕分布，避免十字交叉
                                    setTimeout(() => {
                                        if (graphRef.current && !graphRef.current.destroyed) {
                                            spreadDisconnectedComponents(graphRef.current, () => {
                                                // 布局完成后平滑调整视图
                                                smoothFitView(graphRef.current, 800, 'easeOutCubic');
                                            });
                                        }
                                    }, 30);
                                }
                            },
                            defaultNode: {
                                style: {
                                    lineWidth: 2,
                                    stroke: '#000',
                                    fill: '#fff'
                                },
                                labelCfg: {
                                    style: {
                                        fill: '#000',
                                        fontSize: 16  // 从12增加到16
                                    }
                                }
                            },
                            defaultEdge: {
                                style: {
                                    lineWidth: 1,
                                    stroke: '#000000'
                                },
                                labelCfg: {
                                    style: {
                                        fill: '#000000',
                                        fontSize: 14,  // 从10增加到14
                                        background: {
                                            fill: '#fff',
                                            padding: [2, 4, 2, 4]
                                        }
                                    }
                                }
                            },
                            edgeStateStyles: {
                                hover: {
                                    stroke: '#1890ff',
                                    lineWidth: 2
                                }
                            },
                            defaultEdgeConfig: {
                                type: 'cubic-horizontal',
                                router: {
                                    name: 'orthogonal',
                                    args: {
                                        offset: 25,
                                        maxTurns: 5,
                                        useMaxTurns: false,
                                        gridSize: 1
                                    }
                                },
                                connector: {
                                    name: 'curve',
                                    args: {
                                        curveType: 'cubic-horizontal',
                                        curveOffset: 50
                                    }
                                }
                            },
                            nodeStateStyles: {
                                hover: {
                                    fill: '#e6f7ff',
                                    stroke: '#1890ff'
                                }
                            }
                        });

                        graphRef.current = graph;
                        setHasGraph(true); // 标记图形已生成

                        // Set data and render
                        graph.data({ nodes, edges });
                        graph.render();

                        // 应用初始样式
                        updateGraphStyles(graph, isColored);

                        // 初始渲染后使用平滑动画调整视图
                        setTimeout(() => {
                            smoothFitView(graph, 600, 'easeOutQuart');
                        }, 200);

                        // Enable interactions
                        graph.on('node:mouseenter', (e) => {
                            graph.setItemState(e.item, 'hover', true);
                        });

                        graph.on('node:mouseleave', (e) => {
                            graph.setItemState(e.item, 'hover', false);
                        });

                        // 添加双击编辑功能
                        let editingNode = null;
                        let editInput = null;

                        graph.on('node:dblclick', (e) => {
                            const node = e.item;
                            const model = node.getModel();

                            // 防止重复编辑
                            if (editingNode) {
                                finishEditing(false);
                            }

                            startEditing(node, model);
                        });

                        // 开始编辑节点
                        const startEditing = (node, model) => {
                            editingNode = node;
                            // `getCanvasByPoint` 返回的是相对于 G6 画布左上角的坐标
                            const canvasPoint = graph.getCanvasByPoint(model.x, model.y);
                            // 获取当前缩放比例
                            const currentZoom = graph.getZoom();

                            // 根据节点类型计算输入框的尺寸和位置
                            const getNodeDimensions = (nodeModel) => {
                                const text = nodeModel.label || '';
                                const getTextWidth = (text, fontSize) => {
                                    let width = 0;
                                    for (let char of text) {
                                        if (/[\u4e00-\u9fa5]/.test(char)) {
                                            width += fontSize;
                                        } else {
                                            width += fontSize * 0.6;
                                        }
                                    }
                                    return width;
                                };

                                let width, height, fontSize;

                                if (nodeModel.type === 'entity') {
                                    fontSize = 18;
                                    const textWidth = getTextWidth(text, fontSize);
                                    width = Math.max(80, textWidth + 20);
                                    height = Math.max(50, fontSize + 20);
                                } else if (nodeModel.type === 'relationship') {
                                    fontSize = 16;
                                    const textWidth = getTextWidth(text, fontSize);
                                    const horizontalPadding = 24;
                                    const minWidth = 80;
                                    const requiredWidth = textWidth + horizontalPadding * 2;
                                    const halfWidth = Math.max(minWidth / 2, requiredWidth / 2);
                                    width = halfWidth * 2;
                                    height = Math.max(40, Math.min(halfWidth * 0.6, fontSize + 16) * 2);
                                } else { // attribute
                                    fontSize = 15;
                                    const textWidth = getTextWidth(text, fontSize);
                                    width = Math.max(60, textWidth + 32);
                                    height = Math.max(40, fontSize + 16);
                                }

                                return { width, height, fontSize };
                            };

                            const dimensions = getNodeDimensions(model);
                            // 应用缩放到输入框尺寸和字体
                            const scaledWidth = dimensions.width * currentZoom;
                            const scaledHeight = dimensions.height * currentZoom;
                            const scaledFontSize = dimensions.fontSize * currentZoom;

                            // 根据节点类型获取对应的颜色
                            const getNodeColor = (nodeModel) => {
                                if (nodeModel.type === 'entity') {
                                    return '#0ea5e9'; // 蓝色
                                } else if (nodeModel.type === 'relationship') {
                                    return '#722ed1'; // 紫色
                                } else if (nodeModel.type === 'attribute') {
                                    return nodeModel.keyType === 'pk' ? '#10b981' : '#94a3b8'; // 绿色或灰色
                                }
                                return '#ff8a65'; // 默认橙色
                            };

                            const borderColor = getNodeColor(model);
                            const shadowColor = borderColor.replace('#', 'rgba(') + ', 0.2)'.replace('rgba(', 'rgba(').replace(', 0.2)', ')');
                            const rgbValues = borderColor.substring(1).match(/.{1,2}/g).map(x => parseInt(x, 16));
                            const shadowColorRGB = `rgba(${rgbValues.join(', ')}, 0.2)`;

                            // 创建输入框
                            editInput = document.createElement('input');
                            editInput.type = 'text';
                            editInput.value = model.label || '';
                            editInput.style.position = 'absolute';
                            // 定位是相对于 G6 的容器 (containerRef.current)
                            editInput.style.left = (canvasPoint.x - scaledWidth / 2) + 'px';
                            editInput.style.top = (canvasPoint.y - scaledHeight / 2) + 'px';
                            editInput.style.width = scaledWidth + 'px';
                            editInput.style.height = scaledHeight + 'px';
                            editInput.style.padding = '0';
                            editInput.style.border = `${2 * currentZoom}px solid ${borderColor}`;
                            editInput.style.outline = 'none';
                            editInput.style.fontSize = scaledFontSize + 'px';
                            editInput.style.textAlign = 'center';
                            editInput.style.backgroundColor = 'rgba(255, 255, 255, 0.95)';
                            editInput.style.zIndex = '1000';
                            editInput.style.boxShadow = `0 0 0 ${3 * currentZoom}px ${shadowColorRGB}`;
                            editInput.style.fontWeight = (model.type === 'entity' || model.keyType === 'pk') ? 'bold' : 'normal';

                            // 根据节点类型设置边框样式
                            if (model.type === 'entity') {
                                editInput.style.borderRadius = (4 * currentZoom) + 'px';
                            } else if (model.type === 'relationship') {
                                editInput.style.borderRadius = (8 * currentZoom) + 'px';
                                // 菱形节点用矩形输入框，不旋转以便于编辑
                            } else { // attribute
                                editInput.style.borderRadius = '50%';
                            }

                            // 将输入框附加到 G6 的容器中
                            containerRef.current.appendChild(editInput);
                            editInput.focus();
                            editInput.select();

                            // 监听键盘事件
                            editInput.addEventListener('keydown', (e) => {
                                if (e.key === 'Enter') {
                                    finishEditing(true);
                                    e.preventDefault();
                                } else if (e.key === 'Escape') {
                                    finishEditing(false);
                                    e.preventDefault();
                                }
                            });

                            // 监听失去焦点事件
                            editInput.addEventListener('blur', () => {
                                setTimeout(() => finishEditing(true), 100);
                            });
                        };

                        // 完成编辑
                        const finishEditing = (save) => {
                            if (!editingNode || !editInput) return;

                            if (save && editInput.value.trim()) {
                                const newLabel = editInput.value.trim();
                                const model = editingNode.getModel();

                                // 更新节点标签
                                graph.updateItem(editingNode, {
                                    label: newLabel
                                });

                                // 如果是属性节点，可能需要更新相关的数据结构
                                if (model.type === 'attribute') {
                                    // 可以在这里添加额外的数据同步逻辑
                                    console.log(`属性 ${model.label} 已更新为 ${newLabel}`);
                                } else if (model.type === 'entity') {
                                    console.log(`实体 ${model.label} 已更新为 ${newLabel}`);
                                } else if (model.type === 'relationship') {
                                    console.log(`关系 ${model.label} 已更新为 ${newLabel}`);
                                }
                            }

                            // 清理编辑状态
                            if (editInput && editInput.parentNode) {
                                editInput.parentNode.removeChild(editInput);
                            }
                            editInput = null;
                            editingNode = null;
                        };

                        // 点击画布其他地方也结束编辑
                        graph.on('canvas:click', () => {
                            if (editingNode) {
                                finishEditing(true);
                            }
                        });

                        // 自定义拖拽逻辑：拖动实体时带动相关属性一起移动
                        let draggedEntity = null;
                        let relatedAttributes = [];
                        let dragStartPositions = new Map();

                        graph.on('node:dragstart', (e) => {
                            const node = e.item;
                            const nodeModel = node.getModel();

                            // 只处理实体节点的拖拽
                            if (nodeModel.type === 'entity') {
                                draggedEntity = node;
                                relatedAttributes = [];
                                dragStartPositions.clear();

                                // 记录实体的初始位置
                                dragStartPositions.set(nodeModel.id, { x: nodeModel.x, y: nodeModel.y });

                                // 找到所有相关的属性节点
                                const allNodes = graph.getNodes();
                                allNodes.forEach(n => {
                                    const model = n.getModel();
                                    if (model.type === 'attribute' && model.parentEntity === nodeModel.id) {
                                        relatedAttributes.push(n);
                                        // 记录属性的初始位置
                                        dragStartPositions.set(model.id, { x: model.x, y: model.y });
                                    }
                                });
                            }
                        });

                        graph.on('node:drag', (e) => {
                            const node = e.item;
                            const nodeModel = node.getModel();

                            // 只处理实体节点的拖拽
                            if (nodeModel.type === 'entity' && draggedEntity === node) {
                                const currentPos = { x: nodeModel.x, y: nodeModel.y };
                                const startPos = dragStartPositions.get(nodeModel.id);

                                if (startPos) {
                                    // 计算实体的移动距离
                                    const deltaX = currentPos.x - startPos.x;
                                    const deltaY = currentPos.y - startPos.y;

                                    // 同步移动所有相关的属性节点
                                    relatedAttributes.forEach(attrNode => {
                                        const attrModel = attrNode.getModel();
                                        const attrStartPos = dragStartPositions.get(attrModel.id);

                                        if (attrStartPos) {
                                            const newX = attrStartPos.x + deltaX;
                                            const newY = attrStartPos.y + deltaY;

                                            // 更新属性节点位置
                                            graph.updateItem(attrNode, { x: newX, y: newY });
                                        }
                                    });
                                }
                            }
                        });

                        graph.on('node:dragend', (e) => {
                            const node = e.item;
                            const nodeModel = node.getModel();

                            // 清理拖拽状态
                            if (nodeModel.type === 'entity' && draggedEntity === node) {
                                draggedEntity = null;
                                relatedAttributes = [];
                                dragStartPositions.clear();
                            }
                        });

                        // 自动布局说明：
                        // 1. force布局会自动计算节点位置，避免重叠
                        // 2. 不同类型节点有不同的排斥力和间距
                        // 3. 连线长度根据关系类型自动调整
                        // 4. 布局完成后自动调整视图大小

                    } catch (e) {
                        console.error("SQL Parsing error:", e);
                        setError(`SQL 解析失败: ${e.message}. 请检查SQL语法是否正确。`);
                    } finally {
                        setLoading(false);
                    }
                };

                useEffect(() => {
                    handleGenerate();

                    // Cleanup on unmount
                    return () => {
                        if (graphRef.current) {
                            graphRef.current.destroy();
                        }
                    };
                }, []);

                const handleResize = () => {
                    if (graphRef.current && containerRef.current) {
                        graphRef.current.changeSize(
                            containerRef.current.offsetWidth,
                            containerRef.current.offsetHeight
                        );
                    }
                };

                // 导出SVG功能
                const handleExportSVG = () => {
                    if (!graphRef.current || !hasGraph) {
                        setError('请先生成ER图');
                        return;
                    }

                    try {
                        // 获取当前图形数据，包括节点的实际位置
                        const data = graphRef.current.save();

                        // 创建一个临时容器
                        const tempContainer = document.createElement('div');
                        tempContainer.style.position = 'absolute';
                        tempContainer.style.left = '-9999px';
                        tempContainer.style.top = '-9999px';
                        document.body.appendChild(tempContainer);

                        // 创建临时SVG图形，使用相同的配置
                        const tempGraph = new G6.Graph({
                            container: tempContainer,
                            width: containerRef.current.offsetWidth,
                            height: 600,
                            renderer: 'svg',
                            modes: {
                                default: []
                            },
                            // 不使用布局，直接使用保存的位置
                            layout: null,
                            defaultNode: {
                                style: {
                                    lineWidth: 2,
                                    stroke: '#000',
                                    fill: '#fff'
                                },
                                labelCfg: {
                                    style: {
                                        fill: '#000',
                                        fontSize: 16
                                    }
                                }
                            },
                            defaultEdge: {
                                style: {
                                    lineWidth: 1,
                                    stroke: '#000'
                                },
                                labelCfg: {
                                    style: {
                                        fill: '#000',
                                        fontSize: 14,
                                        background: {
                                            fill: '#fff',
                                            padding: [2, 4, 2, 4]
                                        }
                                    }
                                }
                            },
                            edgeStateStyles: {
                                hover: {
                                    stroke: '#1890ff',
                                    lineWidth: 2
                                }
                            },
                            defaultEdgeConfig: {
                                type: 'cubic-horizontal',
                                router: {
                                    name: 'orthogonal',
                                    args: {
                                        offset: 25,
                                        maxTurns: 5,
                                        useMaxTurns: false,
                                        gridSize: 1
                                    }
                                },
                                connector: {
                                    name: 'curve',
                                    args: {
                                        curveType: 'cubic-horizontal',
                                        curveOffset: 50
                                    }
                                }
                            }
                        });

                        // 读取当前图形数据（包含节点位置）
                        tempGraph.read(data);

                        // 等待渲染完成
                        setTimeout(() => {
                            try {
                                const tempCanvas = tempGraph.get('canvas');
                                const svgElement = tempCanvas.get('el');

                                // 克隆SVG元素以避免修改原始元素
                                const clonedSvg = svgElement.cloneNode(true);

                                // 获取所有图形的边界框
                                const group = tempGraph.getGroup();
                                const bbox = group.getCanvasBBox();

                                // 添加padding
                                const padding = 40;
                                const viewBoxX = bbox.minX - padding;
                                const viewBoxY = bbox.minY - padding;
                                const viewBoxWidth = bbox.width + padding * 2;
                                const viewBoxHeight = bbox.height + padding * 2;

                                // 设置SVG属性以包含完整内容
                                clonedSvg.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
                                clonedSvg.setAttribute('width', viewBoxWidth);
                                clonedSvg.setAttribute('height', viewBoxHeight);
                                clonedSvg.setAttribute('viewBox', `${viewBoxX} ${viewBoxY} ${viewBoxWidth} ${viewBoxHeight}`);

                                // 设置白色背景，使用viewBox的尺寸
                                const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                                rect.setAttribute('x', viewBoxX);
                                rect.setAttribute('y', viewBoxY);
                                rect.setAttribute('width', viewBoxWidth);
                                rect.setAttribute('height', viewBoxHeight);
                                rect.setAttribute('fill', '#ffffff');
                                clonedSvg.insertBefore(rect, clonedSvg.firstChild);

                                const svgString = new XMLSerializer().serializeToString(clonedSvg);
                                downloadSVG(svgString, 'er-diagram.svg');

                                // 清理临时图形和容器
                                tempGraph.destroy();
                                document.body.removeChild(tempContainer);
                            } catch (innerError) {
                                console.error('SVG生成失败:', innerError);
                                setError('SVG生成失败: ' + innerError.message);
                                tempGraph.destroy();
                                if (tempContainer.parentNode) {
                                    document.body.removeChild(tempContainer);
                                }
                            }
                        }, 1000); // 增加等待时间确保渲染完成
                    } catch (error) {
                        console.error('导出SVG失败:', error);
                        setError('导出SVG失败: ' + error.message);
                    }
                };

                // 下载SVG文件
                const downloadSVG = (svgString, filename) => {
                    const blob = new Blob([svgString], { type: 'image/svg+xml' });
                    const url = URL.createObjectURL(blob);
                    const link = document.createElement('a');
                    link.href = url;
                    link.download = filename;
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    URL.revokeObjectURL(url);
                };

                useEffect(() => {
                    window.addEventListener('resize', handleResize);
                    return () => window.removeEventListener('resize', handleResize);
                }, []);

                // 切换背景显示
                const handleToggleBackground = () => {
                    setShowBackground(!showBackground);
                };

                // 强制对齐：最长链水平，支链递归拉直（矩形+菱形），组件分隔避免重叠
                const handleForceAlign = () => {
                    if (!graphRef.current || graphRef.current.destroyed) return;
                    const graph = graphRef.current;
                    const allNodes = graph.getNodes();
                    if (!allNodes.length) return;

                    const carbonNodes = allNodes.filter(n => {
                        const t = n.getModel().nodeType;
                        return t === 'entity' || t === 'relationship';
                    });
                    if (!carbonNodes.length) return;

                    const container = containerRef.current;
                    const canvasWidth = container?.offsetWidth || 1200;
                    const componentGap = 160;

                    const nodeMap = new Map();
                    allNodes.forEach(n => nodeMap.set(n.getModel().id, n));

                    const getRadius = (node) => {
                        const b = node.getBBox();
                        return Math.sqrt(b.width * b.width + b.height * b.height) / 2;
                    };

                    const normalizeAngle = (a) => {
                        let ang = a % (Math.PI * 2);
                        if (ang < 0) ang += Math.PI * 2;
                        return ang;
                    };

                    // 构建仅包含矩形/菱形的邻接表
                    const carbonAdj = new Map();
                    graph.getEdges().forEach(e => {
                        const { source, target } = e.getModel();
                        const sNode = nodeMap.get(source);
                        const tNode = nodeMap.get(target);
                        if (!sNode || !tNode) return;
                        const sType = sNode.getModel().nodeType;
                        const tType = tNode.getModel().nodeType;
                        if ((sType === 'entity' || sType === 'relationship') && (tType === 'entity' || tType === 'relationship')) {
                            if (!carbonAdj.has(source)) carbonAdj.set(source, new Set());
                            if (!carbonAdj.has(target)) carbonAdj.set(target, new Set());
                            carbonAdj.get(source).add(target);
                            carbonAdj.get(target).add(source);
                        }
                    });

                    if (!carbonAdj.size) return;

                    // 计算碳图组件
                    const carbonIds = carbonNodes.map(n => n.getModel().id);
                    const visited = new Set();
                    const components = [];
                    carbonIds.forEach(id => {
                        if (visited.has(id)) return;
                        const stack = [id];
                        const comp = [];
                        visited.add(id);
                        while (stack.length) {
                            const cur = stack.pop();
                            comp.push(cur);
                            const neighbors = carbonAdj.get(cur);
                            if (!neighbors) continue;
                            neighbors.forEach(nb => {
                                if (!visited.has(nb)) {
                                    visited.add(nb);
                                    stack.push(nb);
                                }
                            });
                        }
                        components.push(comp);
                    });

                    // 实体的属性节点映射
                    const entityAttrs = new Map();
                    allNodes.forEach(n => {
                        const m = n.getModel();
                        if (m.nodeType === 'attribute' && m.parentEntity) {
                            if (!entityAttrs.has(m.parentEntity)) entityAttrs.set(m.parentEntity, []);
                            entityAttrs.get(m.parentEntity).push(n);
                        }
                    });

                    const bfsWithin = (start, allowedSet) => {
                        const dist = new Map();
                        const prev = new Map();
                        const queue = [start];
                        dist.set(start, 0);
                        while (queue.length) {
                            const cur = queue.shift();
                            const neighbors = carbonAdj.get(cur);
                            if (!neighbors) continue;
                            neighbors.forEach(nb => {
                                if (!allowedSet.has(nb) || dist.has(nb)) return;
                                dist.set(nb, dist.get(cur) + 1);
                                prev.set(nb, cur);
                                queue.push(nb);
                            });
                        }
                        return { dist, prev };
                    };

                    const findLongestPath = (ids) => {
                        const allowed = new Set(ids);
                        const start = ids[0];
                        const { dist: distA } = bfsWithin(start, allowed);
                        let farA = start;
                        distA.forEach((d, id) => { if (d > distA.get(farA)) farA = id; });
                        const { dist: distB, prev: prevB } = bfsWithin(farA, allowed);
                        let farB = farA;
                        distB.forEach((d, id) => { if (d > distB.get(farB)) farB = id; });
                        const path = [];
                        let cur = farB;
                        while (cur !== undefined) {
                            path.unshift(cur);
                            cur = prevB.get(cur);
                        }
                        return path.length ? path : [start];
                    };

                    // 收集某条支链的节点集合
                    const collectBranch = (start, blocked) => {
                        const allowed = new Set();
                        const stack = [start];
                        allowed.add(start);
                        while (stack.length) {
                            const cur = stack.pop();
                            const neighbors = carbonAdj.get(cur);
                            if (!neighbors) continue;
                            neighbors.forEach(nb => {
                                if (blocked.has(nb) || allowed.has(nb)) return;
                                allowed.add(nb);
                                stack.push(nb);
                            });
                        }
                        return allowed;
                    };

                    const computeSpacing = (size) => {
                        // 复杂度越高，间距越大，避免“一坨”
                        return Math.min(320, 170 + size * 12);
                    };

                    const layoutComponent = (ids) => {
                        const carbonSpacing = computeSpacing(ids.length);
                        const localTargets = new Map();
                        const dirMap = new Map();
                        const allowedSet = new Set(ids);

                        const mainPath = findLongestPath(ids);
                        const mainPathSet = new Set(mainPath);
                        const total = mainPath.length;
                        const startX = -carbonSpacing * (total - 1) / 2;
                        const mainY = 0;
                        mainPath.forEach((id, idx) => {
                            localTargets.set(id, { x: startX + idx * carbonSpacing, y: mainY });
                            dirMap.set(id, { x: 1, y: 0 });
                        });

                        const placed = new Set(mainPath);
                        const queue = [...mainPath];

                        const straightenBranch = (rootId, parentId, angle) => {
                            const blocked = new Set(placed);
                            blocked.add(parentId);
                            const branchSet = collectBranch(rootId, blocked);
                            const path = findLongestPath(Array.from(branchSet));
                            const unit = { x: Math.cos(angle), y: Math.sin(angle) };
                            const parentPos = localTargets.get(parentId);
                            path.forEach((pid, idx) => {
                                const pos = {
                                    x: parentPos.x + unit.x * carbonSpacing * (idx + 1),
                                    y: parentPos.y + unit.y * carbonSpacing * (idx + 1)
                                };
                                localTargets.set(pid, pos);
                                dirMap.set(pid, unit);
                                if (!placed.has(pid)) queue.push(pid);
                                placed.add(pid);
                            });
                        };

                        while (queue.length) {
                            const curId = queue.shift();
                            const curDir = dirMap.get(curId) || { x: 1, y: 0 };
                            const neighbors = carbonAdj.get(curId);
                            if (!neighbors) continue;
                            const unplaced = Array.from(neighbors).filter(id => !placed.has(id));
                            if (!unplaced.length) continue;

                            // 将未放置邻居按支链分组
                            const blockedBase = new Set(placed);
                            blockedBase.add(curId);
                            const seen = new Set();
                            const branches = [];
                            unplaced.forEach(nb => {
                                if (seen.has(nb)) return;
                                const branchNodes = collectBranch(nb, blockedBase);
                                branchNodes.forEach(nid => seen.add(nid));
                                branches.push({ root: nb, nodes: branchNodes, size: branchNodes.size });
                            });

                            // 按支链长度排序，最长优先
                            branches.sort((a, b) => b.size - a.size);

                            const baseAngle = Math.atan2(curDir.y, curDir.x) + Math.PI / 2;
                            const span = branches.length > 1 ? Math.min(Math.PI * 1.5, Math.PI + (branches.length - 1) * 0.2) : Math.PI / 2;
                            const step = branches.length === 1 ? 0 : span / (branches.length - 1);
                            const start = baseAngle - span / 2;

                            branches.forEach((b, idx) => {
                                const angle = start + step * idx;
                                straightenBranch(b.root, curId, angle);
                            });
                        }

                        // 兜底：仍未布局的节点
                        ids.forEach(id => {
                            if (!localTargets.has(id)) {
                                localTargets.set(id, { x: 0, y: 0 });
                            }
                        });

                        // 环绕属性（不移动菱形），记录组件边界
                        const entityIds = ids.filter(id => nodeMap.get(id)?.getModel().nodeType === 'entity');
                        entityIds.forEach(eid => {
                            const entityNode = nodeMap.get(eid);
                            const centerPos = localTargets.get(eid);
                            const relNeighbors = Array.from((carbonAdj.get(eid) || new Set()))
                                .filter(id => allowedSet.has(id) && nodeMap.get(id)?.getModel().nodeType === 'relationship');
                            const attrs = entityAttrs.get(eid) || [];
                            const connectors = relNeighbors.length + attrs.length;
                            if (!connectors) return;

                            const inDir = dirMap.get(eid) || { x: 1, y: 0 };
                            const angleStep = (Math.PI * 2) / connectors;

                            // 槽位角度均分360°
                            const slots = [];
                            for (let i = 0; i < connectors; i++) {
                                slots.push(normalizeAngle(angleStep * i));
                            }

                            // 关系角度（固定，不移动菱形）
                            const relAngles = relNeighbors.map(rid => {
                                const relPos = localTargets.get(rid);
                                if (!relPos) return 0;
                                return normalizeAngle(Math.atan2(relPos.y - centerPos.y, relPos.x - centerPos.x));
                            });

                            const used = new Set();
                            const slotRelMap = new Map(); // slotIdx -> relId

                            // 将关系分配到最近槽位
                            relNeighbors.forEach((rid, idx) => {
                                const ang = relAngles[idx];
                                let bestSlot = -1;
                                let bestDiff = Infinity;
                                slots.forEach((slotAng, sIdx) => {
                                    if (used.has(sIdx)) return;
                                    const diff = Math.min(
                                        Math.abs(slotAng - ang),
                                        Math.PI * 2 - Math.abs(slotAng - ang)
                                    );
                                    if (diff < bestDiff) {
                                        bestDiff = diff;
                                        bestSlot = sIdx;
                                    }
                                });
                                if (bestSlot >= 0) {
                                    used.add(bestSlot);
                                    slotRelMap.set(bestSlot, rid);
                                }
                            });

                            // 计算紧贴半径（仅保证椭圆不重叠，越近越好）
                            const entityR = getRadius(entityNode);
                            const attrR = attrs.length ? Math.max(...attrs.map(a => getRadius(a))) : 30;
                            const gap = 6;
                            const minRadEntity = entityR + attrR + gap;
                            let attrRadius = minRadEntity;
                            if (connectors > 1) {
                                const chordNeed = (attrR * 2 + gap);
                                const denom = Math.sin(angleStep / 2);
                                if (denom > 0.001) {
                                    attrRadius = Math.max(minRadEntity, chordNeed / (2 * denom));
                                }
                            }

                            // 把剩余槽位用于属性，放在最靠近矩形的半径
                            const availableSlots = slots
                                .map((ang, idx) => ({ ang, idx }))
                                .filter(s => !used.has(s.idx))
                                .sort((a, b) => a.idx - b.idx);

                            attrs.forEach((attrNode, aIdx) => {
                                const slot = availableSlots[aIdx % availableSlots.length];
                                const angle = slot.ang;
                                const pos = {
                                    x: centerPos.x + Math.cos(angle) * attrRadius,
                                    y: centerPos.y + Math.sin(angle) * attrRadius
                                };
                                localTargets.set(attrNode.getModel().id, pos);
                            });
                        });

                        // 计算组件边界
                        let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
                        localTargets.forEach((pos, id) => {
                            const node = nodeMap.get(id);
                            if (!node) return;
                            const r = getRadius(node);
                            minX = Math.min(minX, pos.x - r);
                            maxX = Math.max(maxX, pos.x + r);
                            minY = Math.min(minY, pos.y - r);
                            maxY = Math.max(maxY, pos.y + r);
                        });

                        return { targets: localTargets, bounds: { minX, maxX, minY, maxY } };
                    };

                    const componentLayouts = components.map(layoutComponent);

                    // 将组件平铺到画布上，避免互相重叠
                    const globalTargets = new Map();
                    let cursorX = componentGap;
                    let cursorY = componentGap;
                    let rowHeight = 0;
                    componentLayouts.forEach(layout => {
                        const { minX, maxX, minY, maxY } = layout.bounds;
                        const width = (maxX - minX) + componentGap;
                        const height = (maxY - minY) + componentGap;

                        if (cursorX + width > canvasWidth - componentGap) {
                            cursorX = componentGap;
                            cursorY += rowHeight + componentGap;
                            rowHeight = 0;
                        }

                        const offsetX = cursorX - minX;
                        const offsetY = cursorY - minY;

                        layout.targets.forEach((pos, id) => {
                            globalTargets.set(id, { x: pos.x + offsetX, y: pos.y + offsetY });
                        });

                        cursorX += width;
                        rowHeight = Math.max(rowHeight, height);
                    });

                    animateNodesToTargets(graph, globalTargets, 750, () => {
                        graph.refreshPositions();
                        setTimeout(() => smoothFitView(graph, 600, 'easeOutCubic'), 120);
                    });
                };

                // 环绕排布：让属性均匀围绕实体，同时可移动实体以满足关系距离
                const handleArrangeLayout = () => {
                    if (!graphRef.current || graphRef.current.destroyed) return;
                    const graph = graphRef.current;

                    const nodes = graph.getNodes();
                    if (!nodes.length) return;

                    const targets = new Map();
                    const nodeMap = new Map();
                    nodes.forEach(n => nodeMap.set(n.getModel().id, n));
                    const relAnchors = new Map();
                    const relRadii = new Map();

                    const entityNodes = nodes.filter(n => n.getModel().nodeType === 'entity');
                    const attributeNodes = nodes.filter(n => n.getModel().nodeType === 'attribute');
                    const relationshipNodes = nodes.filter(n => n.getModel().nodeType === 'relationship');

                    const getRadius = (node) => {
                        const bbox = node.getBBox();
                        // 使用对角线的一半作为半径，确保旋转时也不会重叠
                        // 这样可以更好地处理长方形元素
                        return Math.sqrt(bbox.width * bbox.width + bbox.height * bbox.height) / 2;
                    };

                    const normalizeAngle = (a) => {
                        let angle = a % (Math.PI * 2);
                        if (angle < 0) angle += Math.PI * 2;
                        return angle;
                    };

                    // 建立关系节点与实体节点的对应
                    const relationshipConnections = new Map(); // relId -> Set<entityNode>
                    graph.getEdges().forEach(edge => {
                        const { source, target } = edge.getModel();
                        const sourceNode = nodeMap.get(source);
                        const targetNode = nodeMap.get(target);
                        if (!sourceNode || !targetNode) return;
                        const sType = sourceNode.getModel().nodeType;
                        const tType = targetNode.getModel().nodeType;
                        if (sType === 'relationship' && tType === 'entity') {
                            if (!relationshipConnections.has(source)) relationshipConnections.set(source, new Set());
                            relationshipConnections.get(source).add(targetNode);
                        } else if (tType === 'relationship' && sType === 'entity') {
                            if (!relationshipConnections.has(target)) relationshipConnections.set(target, new Set());
                            relationshipConnections.get(target).add(sourceNode);
                        }
                    });

                    // 按实体收集属性与关系
                    const entityInfo = new Map(); // entityId -> {node, attrs:[], rels:[], satellites:[]}
                    entityNodes.forEach(e => entityInfo.set(e.getModel().id, { node: e, attrs: [], rels: [], satellites: [] }));
                    attributeNodes.forEach(a => {
                        const pid = a.getModel().parentEntity;
                        const info = entityInfo.get(pid);
                        if (info) {
                            info.attrs.push(a);
                            info.satellites.push({ node: a, type: 'attr' }); // 统一管理卫星节点
                        }
                    });
                    relationshipNodes.forEach(r => {
                        const set = relationshipConnections.get(r.getModel().id);
                        if (set) {
                            const connected = Array.from(set);
                            connected.forEach(entityNode => {
                                const info = entityInfo.get(entityNode.getModel().id);
                                if (!info) return;
                                // 找到另一端实体
                                const other = connected.find(n => n !== entityNode) || null;
                                info.rels.push({ relNode: r, otherEntity: other });
                                info.satellites.push({ node: r, type: 'rel', otherEntity: other }); // 统一管理卫星节点
                            });
                        }
                    });

                    // 当前实体坐标，可被迭代矫正
                    const entityPositions = new Map();
                    entityNodes.forEach(n => {
                        const m = n.getModel();
                        entityPositions.set(m.id, { x: m.x, y: m.y });
                    });

                    // 计算每个实体的统一环绕半径（所有卫星节点使用相同半径）
                    const baseRing = new Map(); // 统一的环绕半径（中心到卫星中心）
                    const systemRadius = new Map(); // 实体的碰撞半径（中心到卫星外沿）

                    entityInfo.forEach(info => {
                        const entityRadius = getRadius(info.node);

                        // 获取所有卫星节点（属性+关系）的最大半径
                        const maxSatelliteRadius = info.satellites.length > 0
                            ? Math.max(...info.satellites.map(s => getRadius(s.node)))
                            : 30;

                        // 基础环半径：实体半径 + 最大卫星半径 + 间隙
                        let ringR = entityRadius + maxSatelliteRadius + 25;

                        // 检查周长需求：确保所有卫星节点能均匀分布且不重叠
                        if (info.satellites.length > 1) {
                            const count = info.satellites.length;
                            // 每个卫星节点需要的弧长 = 直径 + 间隙
                            const requiredArcLength = maxSatelliteRadius * 2 + 18;
                            const totalCircumference = count * requiredArcLength;
                            const requiredRingR = totalCircumference / (2 * Math.PI);
                            ringR = Math.max(ringR, requiredRingR);
                        }

                        baseRing.set(info.node.getModel().id, ringR);
                        // 系统半径 = 环半径 + 最大卫星半径 (这是实体的最外层边界)
                        systemRadius.set(info.node.getModel().id, ringR + maxSatelliteRadius);
                    });

                    // 弹簧迭代 + 碰撞检测
                    const safeGap = 50; // 实体系统之间的安全间距
                    const entityIds = Array.from(entityPositions.keys());

                    for (let iter = 0; iter < 300; iter++) {
                        let maxMove = 0;

                        // 1. 吸引力：通过关系连接的实体
                        relationshipNodes.forEach(relNode => {
                            const relId = relNode.getModel().id;
                            const connected = relationshipConnections.get(relId);
                            if (!connected || connected.size !== 2) return;
                            const [entityA, entityB] = Array.from(connected.values());
                            const idA = entityA.getModel().id;
                            const idB = entityB.getModel().id;
                            const posA = entityPositions.get(idA);
                            const posB = entityPositions.get(idB);
                            if (!posA || !posB) return;

                            const dx = posB.x - posA.x;
                            const dy = posB.y - posA.y;
                            const dist = Math.hypot(dx, dy) || 1;

                            // 期望距离 = 两个实体的系统半径之和 + 间隙
                            const rA = systemRadius.get(idA);
                            const rB = systemRadius.get(idB);
                            const desired = rA + rB + safeGap;

                            const diff = desired - dist;
                            if (Math.abs(diff) < 1) return;

                            const nx = dx / dist;
                            const ny = dy / dist;
                            // 移动系数，距离越远拉力越大，距离越近斥力越大
                            const move = (diff * 0.2) / 2;

                            posA.x -= nx * move;
                            posA.y -= ny * move;
                            posB.x += nx * move;
                            posB.y += ny * move;
                            maxMove = Math.max(maxMove, Math.abs(move));
                        });

                        // 2. 全局斥力：防止任意两个实体重叠
                        for (let i = 0; i < entityIds.length; i++) {
                            for (let j = i + 1; j < entityIds.length; j++) {
                                const idA = entityIds[i];
                                const idB = entityIds[j];
                                const posA = entityPositions.get(idA);
                                const posB = entityPositions.get(idB);

                                const dx = posB.x - posA.x;
                                const dy = posB.y - posA.y;
                                const dist = Math.hypot(dx, dy) || 1;

                                const rA = systemRadius.get(idA);
                                const rB = systemRadius.get(idB);
                                const minDesc = rA + rB + safeGap; // 最小允许距离

                                if (dist < minDesc) {
                                    // 发生重叠或距离过近，施加斥力
                                    const overlap = minDesc - dist;
                                    const nx = dx / dist;
                                    const ny = dy / dist;
                                    const move = overlap * 0.5 * 0.5; // 较强的斥力

                                    posA.x -= nx * move;
                                    posA.y -= ny * move;
                                    posB.x += nx * move;
                                    posB.y += ny * move;
                                    maxMove = Math.max(maxMove, move);
                                }
                            }
                        }

                        if (maxMove < 0.5) break;
                    }

                    // 调整实体间距，让关系菱形可以放在中点且连线等长
                    const ensureRelationshipClearance = () => {
                        // 预留给关系节点的最小半径与间隙
                        const clearanceGap = 12;

                        relationshipNodes.forEach(relNode => {
                            const relId = relNode.getModel().id;
                            const connected = relationshipConnections.get(relId);
                            if (!connected || connected.size !== 2) return;

                            const [entityA, entityB] = Array.from(connected.values());
                            const idA = entityA.getModel().id;
                            const idB = entityB.getModel().id;
                            const posA = entityPositions.get(idA);
                            const posB = entityPositions.get(idB);
                            if (!posA || !posB) return;

                            const dx = posB.x - posA.x;
                            const dy = posB.y - posA.y;
                            const dist = Math.hypot(dx, dy) || 1;

                            const relRadius = getRadius(relNode);
                            // 以两端属性环半径为基准，保证菱形位于两实体外圈之外
                            const minHalf = Math.max(
                                (baseRing.get(idA) || 40) + relRadius + clearanceGap,
                                (baseRing.get(idB) || 40) + relRadius + clearanceGap
                            );

                            const requiredDist = minHalf * 2;
                            if (dist >= requiredDist) return;

                            const missing = requiredDist - dist;
                            const nx = dx / dist;
                            const ny = dy / dist;

                            // 对称地推开两个实体
                            posA.x -= nx * missing / 2;
                            posA.y -= ny * missing / 2;
                            posB.x += nx * missing / 2;
                            posB.y += ny * missing / 2;
                        });
                    };

                    // 运行三轮，传播推开效果
                    ensureRelationshipClearance();
                    ensureRelationshipClearance();
                    ensureRelationshipClearance();

                    // 实体目标位置
                    // 实体目标位置
                    entityPositions.forEach((pos, id) => targets.set(id, { ...pos }));

                    const entityOrbitRadius = new Map();

                    // 统一布局所有卫星节点(属性+单实体关系)
                    entityInfo.forEach(info => {
                        const { node, satellites } = info;
                        const model = node.getModel();
                        const center = entityPositions.get(model.id) || { x: model.x, y: model.y };

                        // 使用预计算的统一环绕半径
                        const ringRadius = baseRing.get(model.id);
                        entityOrbitRadius.set(model.id, ringRadius);

                        if (!satellites.length) return;

                        // 找出需要避开的角度(双实体关系的方向)
                        const avoidAngles = [];
                        satellites.forEach(s => {
                            if (s.type === 'rel' && s.otherEntity) {
                                const otherPos = entityPositions.get(s.otherEntity.getModel().id);
                                if (otherPos) {
                                    const angle = normalizeAngle(Math.atan2(otherPos.y - center.y, otherPos.x - center.x));
                                    avoidAngles.push(angle);
                                }
                            }
                        });

                        // 计算可用角度区间
                        const gapAngle = 0.35; // 关系方向留白角度
                        const halfGap = gapAngle / 2;
                        let segments = [];

                        if (!avoidAngles.length) {
                            // 没有需要避开的角度,整圈可用
                            segments.push({ start: 0, end: Math.PI * 2 });
                        } else {
                            // 计算各个可用区间
                            const sortedAngles = avoidAngles.slice().sort((a, b) => a - b);
                            const total = Math.PI * 2;
                            for (let i = 0; i < sortedAngles.length; i++) {
                                const curr = sortedAngles[i];
                                const next = sortedAngles[(i + 1) % sortedAngles.length] + (i === sortedAngles.length - 1 ? total : 0);
                                const start = curr + halfGap;
                                const end = next - halfGap;
                                if (end > start) segments.push({ start, end });
                            }
                        }

                        // 检查总可用角度
                        const totalFree = segments.reduce((sum, s) => sum + (s.end - s.start), 0);
                        if (totalFree <= 0) {
                            // 间隙被占满,退化为整圈
                            segments = [{ start: 0, end: Math.PI * 2 }];
                        }

                        // 收集需要在环上布局的卫星节点(排除双实体关系)
                        const orbitalSatellites = satellites.filter(s =>
                            s.type === 'attr' || (s.type === 'rel' && !s.otherEntity)
                        );

                        if (!orbitalSatellites.length) return;

                        // 按当前角度排序,减少位移
                        const sortedSatellites = orbitalSatellites.slice().sort((a, b) => {
                            const ma = a.node.getModel();
                            const mb = b.node.getModel();
                            const angleA = normalizeAngle(Math.atan2(ma.y - center.y, ma.x - center.x));
                            const angleB = normalizeAngle(Math.atan2(mb.y - center.y, mb.x - center.x));
                            return angleA - angleB;
                        });

                        // 在所有可用区间内均匀分配卫星节点
                        const totalCount = sortedSatellites.length;
                        const totalAngle = segments.reduce((sum, s) => sum + (s.end - s.start), 0);

                        // 计算每个区间应分配的节点数
                        const segCounts = segments.map(s =>
                            Math.max(0, Math.round(totalCount * (s.end - s.start) / totalAngle))
                        );

                        // 调整分配数量,确保总和正确
                        let allocated = segCounts.reduce((sum, c) => sum + c, 0);
                        let segIdx = 0;
                        while (allocated < totalCount) {
                            // 找最大的区间增加一个
                            let maxIdx = 0;
                            let maxLen = -Infinity;
                            segments.forEach((s, idx) => {
                                if (s.end - s.start > maxLen) {
                                    maxLen = s.end - s.start;
                                    maxIdx = idx;
                                }
                            });
                            segCounts[maxIdx]++;
                            allocated++;
                        }
                        while (allocated > totalCount) {
                            // 找有分配的区间减少一个
                            for (let i = segCounts.length - 1; i >= 0; i--) {
                                if (segCounts[i] > 0) {
                                    segCounts[i]--;
                                    allocated--;
                                    break;
                                }
                            }
                        }

                        // 在每个区间内均匀放置节点
                        let nodeIdx = 0;
                        segments.forEach((s, idx) => {
                            const count = segCounts[idx];
                            if (!count) return;

                            // 计算该区间内的角度步长
                            const step = (s.end - s.start) / count;

                            for (let i = 0; i < count; i++) {
                                // 均匀分布:从区间起点+半步长开始
                                const angle = s.start + step * (i + 0.5);
                                const useAngle = normalizeAngle(angle);

                                const targetX = center.x + ringRadius * Math.cos(useAngle);
                                const targetY = center.y + ringRadius * Math.sin(useAngle);

                                const satellite = sortedSatellites[nodeIdx++];
                                if (satellite) {
                                    targets.set(satellite.node.getModel().id, { x: targetX, y: targetY });
                                }
                            }
                        });
                    });

                    // 双实体关系节点：沿实体连线分布,确保到两端的距离相等
                    relationshipNodes.forEach(relNode => {
                        const relId = relNode.getModel().id;
                        const connectedEntities = relationshipConnections.get(relId);

                        if (connectedEntities && connectedEntities.size === 2) {
                            const [entityA, entityB] = Array.from(connectedEntities.values());
                            const idA = entityA.getModel().id;
                            const idB = entityB.getModel().id;
                            const posA = entityPositions.get(idA);
                            const posB = entityPositions.get(idB);
                            if (!posA || !posB) return;

                            const dx = posB.x - posA.x;
                            const dy = posB.y - posA.y;
                            const dist = Math.hypot(dx, dy) || 1;

                            // 将关系节点放在两实体的几何中心,使连线长度相等
                            const midX = (posA.x + posB.x) / 2;
                            const midY = (posA.y + posB.y) / 2;

                            const anchorPos = { x: midX, y: midY };
                            targets.set(relId, anchorPos);
                            relAnchors.set(relId, anchorPos);
                            relRadii.set(relId, getRadius(relNode));
                        }
                        // 注意:单实体关系已在上面的统一卫星布局中处理
                    });

                    // 同一实体对之间的多个关系菱形分布到垂直方向，避免重叠
                    const groupedRelations = new Map(); // key: sortedEntityIdA-IdB => [{relNode, relRadius, entities}]
                    relationshipNodes.forEach(relNode => {
                        const relId = relNode.getModel().id;
                        const connected = relationshipConnections.get(relId);
                        if (!connected || connected.size !== 2) return;
                        const [entityA, entityB] = Array.from(connected.values());
                        const idA = entityA.getModel().id;
                        const idB = entityB.getModel().id;
                        const key = idA < idB ? `${idA}__${idB}` : `${idB}__${idA}`;
                        if (!groupedRelations.has(key)) groupedRelations.set(key, []);
                        groupedRelations.get(key).push({
                            relNode,
                            relRadius: getRadius(relNode),
                            entities: [entityA, entityB]
                        });
                    });

                    groupedRelations.forEach(list => {
                        if (list.length <= 1) return;
                        // 基于中心点进行垂直偏移
                        const sample = list[0];
                        const [entityA, entityB] = sample.entities;
                        const idA = entityA.getModel().id;
                        const idB = entityB.getModel().id;
                        const posA = entityPositions.get(idA);
                        const posB = entityPositions.get(idB);
                        if (!posA || !posB) return;
                        const dx = posB.x - posA.x;
                        const dy = posB.y - posA.y;
                        const dist = Math.hypot(dx, dy) || 1;
                        const nx = dx / dist;
                        const ny = dy / dist;
                        // 垂直方向单位向量
                        const px = -ny;
                        const py = nx;

                        const baseX = targets.get(sample.relNode.getModel().id)?.x || (posA.x + posB.x) / 2;
                        const baseY = targets.get(sample.relNode.getModel().id)?.y || (posA.y + posB.y) / 2;
                        const maxRadius = Math.max(...list.map(item => item.relRadius));
                        const offsetStep = maxRadius * 2 + 16;

                        // 以中心为对称点分布
                        const sorted = list.slice().sort((a, b) => a.relNode.getModel().id.localeCompare(b.relNode.getModel().id));
                        const mid = (sorted.length - 1) / 2;
                        sorted.forEach((item, idx) => {
                            const offsetIndex = idx - mid;
                            const ox = px * offsetIndex * offsetStep;
                            const oy = py * offsetIndex * offsetStep;
                            const newPos = { x: baseX + ox, y: baseY + oy };
                            const rid = item.relNode.getModel().id;
                            targets.set(rid, newPos);
                            relAnchors.set(rid, newPos);
                        });
                    });

                    // 关系节点额外防重叠修正：对关系节点间、关系节点与实体做轻量斥力，保持锚点附近
                    if (relAnchors.size) {
                        const relPositions = new Map();
                        relAnchors.forEach((anchor, id) => {
                            const t = targets.get(id);
                            relPositions.set(id, t ? { ...t } : { ...anchor });
                        });

                        const entityCollisionRadius = new Map();
                        entityNodes.forEach(en => {
                            const mid = en.getModel();
                            const ring = entityOrbitRadius.get(mid.id) || baseRing.get(mid.id) || 60;
                            // 让关系节点远离实体外圈
                            entityCollisionRadius.set(mid.id, ring + 20);
                        });

                        for (let iter = 0; iter < 80; iter++) {
                            // 关系节点间斥力
                            relationshipNodes.forEach((relA, idxA) => {
                                const idA = relA.getModel().id;
                                const posA = relPositions.get(idA);
                                const rA = relRadii.get(idA) || 30;
                                if (!posA) return;

                                for (let j = idxA + 1; j < relationshipNodes.length; j++) {
                                    const relB = relationshipNodes[j];
                                    const idB = relB.getModel().id;
                                    const posB = relPositions.get(idB);
                                    const rB = relRadii.get(idB) || 30;
                                    if (!posB) continue;

                                    const dx = posB.x - posA.x;
                                    const dy = posB.y - posA.y;
                                    let dist = Math.hypot(dx, dy);
                                    if (dist === 0) dist = 0.01;
                                    const minDist = rA + rB + 14;
                                    if (dist < minDist) {
                                        const push = (minDist - dist) / 2;
                                        const nx = dx / dist;
                                        const ny = dy / dist;
                                        posA.x -= nx * push;
                                        posA.y -= ny * push;
                                        posB.x += nx * push;
                                        posB.y += ny * push;
                                    }
                                }
                            });

                            // 关系节点避开实体外圈
                            relPositions.forEach((pos, rid) => {
                                // 找到关联的实体
                                const relNode = graph.findById(rid);
                                const connected = relNode ? relationshipConnections.get(rid) : null;
                                if (!connected) return;

                                connected.forEach(entNode => {
                                    const em = entNode.getModel();
                                    const center = entityPositions.get(em.id) || { x: em.x, y: em.y };
                                    const limit = entityCollisionRadius.get(em.id) || 80;
                                    const dx = pos.x - center.x;
                                    const dy = pos.y - center.y;
                                    let dist = Math.hypot(dx, dy);
                                    if (dist === 0) dist = 0.01;
                                    if (dist < limit) {
                                        const push = (limit - dist);
                                        const nx = dx / dist;
                                        const ny = dy / dist;
                                        pos.x += nx * push;
                                        pos.y += ny * push;
                                    }
                                });
                            });

                            // 轻微拉回锚点，防止漂移过远
                            relPositions.forEach((pos, id) => {
                                const anchor = relAnchors.get(id);
                                if (!anchor) return;
                                pos.x = pos.x * 0.85 + anchor.x * 0.15;
                                pos.y = pos.y * 0.85 + anchor.y * 0.15;
                            });
                        }

                        // 应用修正后的关系位置
                        relPositions.forEach((pos, id) => {
                            targets.set(id, { ...pos });
                        });
                    }

                    // 全局防重叠（所有形状）
                    const applyGlobalSeparation = () => {
                        const allNodes = graph.getNodes();
                        const meta = allNodes.map(n => ({
                            id: n.getModel().id,
                            r: getRadius(n)
                        }));
                        // 确保每个节点都有目标
                        meta.forEach(m => {
                            if (!targets.has(m.id)) {
                                const model = graph.findById(m.id)?.getModel();
                                targets.set(m.id, { x: model?.x || 0, y: model?.y || 0 });
                            }
                        });

                        for (let iter = 0; iter < 400; iter++) {
                            let maxMove = 0;
                            for (let i = 0; i < meta.length; i++) {
                                for (let j = i + 1; j < meta.length; j++) {
                                    const a = meta[i], b = meta[j];
                                    const pa = targets.get(a.id);
                                    const pb = targets.get(b.id);
                                    if (!pa || !pb) continue;
                                    const dx = pb.x - pa.x;
                                    const dy = pb.y - pa.y;
                                    let dist = Math.hypot(dx, dy);
                                    if (dist === 0) dist = 0.01;
                                    const minDist = a.r + b.r + 8;
                                    if (dist < minDist) {
                                        const push = (minDist - dist) / 2;
                                        const nx = dx / dist;
                                        const ny = dy / dist;
                                        pa.x -= nx * push;
                                        pa.y -= ny * push;
                                        pb.x += nx * push;
                                        pb.y += ny * push;
                                        maxMove = Math.max(maxMove, push);
                                    }
                                }
                            }
                            if (maxMove < 0.3) break;
                        }
                    };

                    applyGlobalSeparation();

                    animateNodesToTargets(graph, targets, 850, () => {
                        smoothFitView(graph, 800, 'easeOutCubic');
                    });
                };

                return (
                    <div className="main-content">
                        <div className="input-section">
                            <div className="card">
                                <div className="card-header">
                                    <h2 className="card-title">
                                        <span style={{ fontSize: '1.5rem' }}>📄</span>
                                        SQL / DBML 输入
                                    </h2>
                                </div>
                                <div className="card-content">
                                    <div style={{ height: '480px', display: 'flex', flexDirection: 'column' }}>
                                        <CodeEditor
                                            value={inputText}
                                            onChange={setInputText}
                                            placeholder="在此处粘贴您的 CREATE TABLE 或 DBML 语句..."
                                        />
                                    </div>
                                    <div className="button-group">
                                        <button
                                            className="btn btn-primary"
                                            onClick={handleGenerate}
                                            disabled={loading}
                                        >
                                            {loading ? <div className="spinner" style={{ width: 20, height: 20, borderWidth: 2 }}></div> : '⚡ 生成ER图'}
                                        </button>
                                        <button
                                            className="btn btn-secondary"
                                            onClick={handleExportSVG}
                                            disabled={!hasGraph}
                                        >
                                            📥 导出SVG
                                        </button>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <div className="output-section">
                            <div className="card">
                                <div className="card-header" style={{ flexWrap: 'wrap', gap: '16px', height: 'auto' }}>
                                    <div style={{ display: 'flex', alignItems: 'center', gap: '24px', flex: 1, minWidth: '300px' }}>
                                        <h2 className="card-title" style={{ whiteSpace: 'nowrap' }}>
                                            <span style={{ fontSize: '1.5rem' }}>🎨</span>
                                            ER图预览
                                        </h2>

                                        <div style={{ display: 'flex', gap: '8px', alignItems: 'center', flexWrap: 'wrap' }}>
                                            <div className="legend-item" style={{ padding: '4px 10px', fontSize: '0.8rem' }}>
                                                <div style={{ width: '10px', height: '10px', borderRadius: '3px', background: isColored ? '#e0f2fe' : '#fff', border: isColored ? '2px solid #0ea5e9' : '2px solid #1e293b' }}></div>
                                                <span>实体</span>
                                            </div>
                                            <div className="legend-item" style={{ padding: '4px 10px', fontSize: '0.8rem' }}>
                                                <div style={{ width: '10px', height: '10px', transform: 'rotate(45deg)', background: isColored ? '#f5f3ff' : '#fff', border: isColored ? '2px solid #8b5cf6' : '2px solid #1e293b' }}></div>
                                                <span style={{ marginLeft: '4px' }}>关系</span>
                                            </div>
                                            <div className="legend-item" style={{ padding: '4px 10px', fontSize: '0.8rem' }}>
                                                <div style={{ width: '10px', height: '10px', borderRadius: '50%', background: isColored ? '#fff' : '#fff', border: isColored ? '2px solid #94a3b8' : '1px solid #1e293b' }}></div>
                                                <span>属性</span>
                                            </div>
                                            <div className="legend-item" style={{ padding: '4px 10px', fontSize: '0.8rem' }}>
                                                <div style={{ width: '10px', height: '10px', borderRadius: '50%', background: isColored ? '#ecfdf5' : '#fff', border: isColored ? '2px solid #10b981' : '2px solid #1e293b' }}></div>
                                                <span style={{ fontWeight: 600, color: isColored ? '#059669' : 'inherit' }}>主键</span>
                                            </div>
                                        </div>
                                    </div>

                                    <div style={{ display: 'flex', alignItems: 'center', gap: '16px', marginLeft: 'auto' }}>
                                        <div style={{ fontSize: '0.85rem', color: 'var(--text-sub)', opacity: 0.8, whiteSpace: 'nowrap', marginRight: '8px' }}>
                                            🖱️ 双击编辑 • 滚轮缩放
                                        </div>
                                        <button
                                            className="btn btn-sm btn-accent"
                                            onClick={handleArrangeLayout}
                                            disabled={!hasGraph || loading}
                                        >
                                            ✨ 智能布局
                                        </button>
                                        <button
                                            className="btn btn-sm btn-accent"
                                            onClick={handleForceAlign}
                                            disabled={!hasGraph || loading}
                                        >
                                            📐 强制对齐
                                        </button>
                                    </div>
                                </div>

                                <div className="card-content" style={{ position: 'relative', padding: 0, display: 'flex', flexDirection: 'column', height: '100%' }}>
                                    {error && (
                                        <div className="error-message" style={{ margin: '20px' }}>
                                            ⚠️ {error}
                                        </div>
                                    )}

                                    <div className={`diagram-container ${showBackground ? '' : 'no-grid'}`} style={{ border: 'none', borderRadius: 0 }}>
                                        <div
                                            className="background-toggle"
                                            onClick={handleToggleBackground}
                                            title={showBackground ? '隐藏背景' : '显示背景'}
                                        >
                                            <i className={`fa-solid ${showBackground ? 'fa-eye' : 'fa-eye-slash'}`}></i>
                                        </div>
                                        <div
                                            className={`colorize-toggle ${isColored ? 'active' : ''}`}
                                            onClick={() => setIsColored(!isColored)}
                                            title={isColored ? '关闭着色' : '开启着色'}
                                        >
                                            <i className="fa-solid fa-palette"></i>
                                        </div>
                                        {loading && (
                                            <div className="loading-overlay">
                                                <div className="spinner"></div>
                                            </div>
                                        )}
                                        <div
                                            ref={containerRef}
                                            style={{
                                                width: '100%',
                                                height: '100%',
                                                position: 'relative'
                                            }}
                                        />
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                );
            };

            const root = ReactDOM.createRoot(document.getElementById('root'));
            root.render(
                <React.StrictMode>
                    <App />
                </React.StrictMode>
            );
        });
    </script>
</body>

</html>